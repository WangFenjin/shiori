---
title: "CPU只有一个，为什么看起来却是无穷无尽的？"
---

本文主要根据 <a href="http://120.52.72.44/pages.cs.wisc.edu/c3pr90ntcsf0/~remzi/OSTEP/cpu-intro.pdf">OSTEP 第四章</a> 总结而来。

进程就是运行中的程序，它是操作系统中最基本的概念。我们知道，一台电脑既可以运行浏览器，又可以看视频，还能听音乐，实际上操作系统同时运行了很多程序。那么，操作系统是怎么让用户看起来有很多CPU的呢？

## 时间共享
这里用的是CPU时间共享技术。操作系统通过运行一个程序，然后把它停下来去运行另一个程序，如此继续，让人以为有很多个CPU。所有操作系统都使用了时间共享技术，为了实现它，操作系统需要底层硬件机制(mechanisms)的支持和上层策略(policies)的帮助。

* 机制解决了具体怎么做(how)的问题，比如系统是怎么做进程切换的？
* 策略解决了资源调度(which)的问题，比如系统调度哪个进程来运行？

软件设计中模块化是核心概念，机制和策略其实也是一种模块化的思想。策略只需要解决需要做什么，具体怎么做交给机制来完成就可以了。

## 进程
上面说到操作系统可以同时运行很多个进程，那么系统是怎么管理这些进程的呢？
操作系统主要有下面5类操作进程的API：

1. 创建。操作系统可以创建一个进程，比如用户双击图标运行程序。
2. 销毁。虽然很多进程自己运行完会自动销毁，但是用户有时候还是希望能杀死一个进程。
3. 等待。用来等待一个进程执行完毕。
4. 其他类型的控制。除了销毁和等待，操作系统还希望可以暂停一个运行中的进程（以让出CPU给别的进程用），或者恢复一个暂停的进程。
5. 状态。输出进程目前的状态信息，比如这个进程运行了多久，目前是处于等待的状态还是运行的状态等等。

进程的创建过程如下图所示：
![进程创建过程](/images/ostep4.1.jpg "进程创建过程")

1. 操作系统把程序（代码和静态数据）从硬盘加载到内存中。早期版本的操作系统会把所有数据都统一加载到内存，现代操作系统有了分页和交换空间的概念，所以采取的是lazy的方式，按需加载。程序加载完成之后，操作系统开始运行这个程序。
2. 创建栈。用于保存局部变量，函数参数，返回地址等。main()函数的argc和argv参数就是在栈里面初始化的。
3. 创建堆。malloc()会在堆中获取一段内存，然后通过free()释放。很多数据结构比如链表，哈希表，树等都依赖堆。
4. 初始化I/O。对每个进程，UNIX系统会初始化三个文件描述符，标准输入、标准输出和标准错误输出。
5. 栈、堆和I/O被初始化完成之后，操作系统调用main()函数，进程就运行起来了。

进程运行起来之后，操作系统会对它进行调度，进程会在不同的状态下切换，如图所示：
![进程状态切换](/images/ostep4.2.jpg "进程状态切换")
可以看到，进程主要在运行、就绪和阻塞三种状态下切换，切换是由操作系统的调度器决定的。

## PCB
操作系统同时可以运行很多的进程，那么就需要管理好这些进程。系统是通过进程列表来管理这些进程的，列表中每个项标示了单个进程的相关信息，也被叫做Process Control Block(PCB)。xv6内核的进程数据结构如下图所示：
![进程数据结构](/images/ostep4.5.jpg "进程数据结构")

1. context 是操作系统做进程切换时需要保存或者读取的数据，这些数据被放到寄存器中。
2. proc_state 是进程可能状态，可以看到出了运行、就绪、阻塞，还有初始化和zombie状态。zombie状态表示进程已经退出了但是还未被清理，父进程可以从中读取运行状态（Unix中一般正常退出返回0，异常返回非0），还可以告知系统可以回收相关资源了。
3. proc 包含了context和进程的其他信息，具体可以看注释。

## 总结
本文主要介绍了进程的基本概念，以及操作系统是怎么把程序运行起来的。但是还没有具体介绍操作系统具体是怎么做到的(mechanisms)以及调度策略是什么(policies)，以后再逐一介绍。
