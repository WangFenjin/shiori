---
title: "为什么 Dennis Ritchie 把fork和exec这两个系统调用分开？"
---

本文主要根据 <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf">OSTEP 第5章</a> 总结而来。

<a href="http://toutiao.com/i6246736448540639746/">上篇文章</a> 我们知道CPU通过时间共享的方式，可以同时运行很多进程，同时我们也整理了进程的创建过程和状态转换的过程。今天我们来看一个具体的例子，看Unix系统提供的操作进程的API具体做了什么，以及为什么需要这些API。

熟悉Unix的读者最先想到的可能是fork() 和 exec()，我们也从它们谈起。fork() 和 exec() 可能会是你见过的最“奇葩”的API了。

## fork, exec, wait
简单来说，fork() 用于创建一个新进程；wait() 用于阻塞父进程，直到子进程退出(这其实是不准确的，wait() 有可能在子进程没有退出时也会返回，比如在子进程收到信号导致状态变化的时候)；而exec() 用于在创建的子进程中执行其他程序。下面通过具体代码来分析。

![fork, exec and wait](/images/ostep_p3_fork_exec_wait.jpg "fork, exec and wait")

1. L10，getpid() 会返回当前进程的process identifier(PID)，pid唯一标识了一个进程，可以通过pid来控制一个进程比如让它停止运行。
2. L11, fork()
  1. fork() 函数首先会创建一个子进程，这个子进程是父进程的一个拷贝
  2. 也就是说，调用fork() 之后，系统会看到两个一样的程序在运行，并且两个程序都正在从调用fork() 的过程中返回
  3. 根据2.2，子进程被创建出来之后不是从main() 函数开始执行的，而是从调用fork() 返回的那个点开始执行
  4. 我们说子进程是父进程的一个拷贝，但是它们还是有区别的。比如子进程有它自己的地址空间，自己的寄存器，自己的PC等等。
  5. 特别值得说的一个区别是，子进程从fork() 得到的返回值是0，而父进程得到的返回值大于0(如果小于0表示创建子进程失败了)。这就让我们可以根据返回值的不同判断两个进程哪个是父进程，哪个是子进程。
3. L12-15 fork() 返回值小于0，程序退出
4. L16-24 由于返回值是0，所以当前进程是子进程。在进程中，调用execvp() 运行 `wc` 命令，计算程序文件本身的字符数。exec() 是一个函数族，execvp() 只是它的一个变体。
  * 如果说fork() 函数很奇怪，那exec() 函数也不是善茬。它首先把将要运行的程序代码和静态数据载入内存，然后进行必要的初始化比如堆、栈，然后用传进来的参数当作argv 运行这个目标程序。也就是说，exec() 把当前正在运行的程序<b>替换</b>成了目标程序，就像当前程序从没运行过一样。
5. L25-30 父进程里面调用wait(), 等待子进程推出之后自己再退出。如果不调用wait(), 程序的行为是不确定的，有可能是父进程先退出，也可能是子进程先退出。

程序的输出如下图所示：

![fork, exec and wait 输出](/images/ostep_p3_fork_exec_wait.jpg "fork, exec and wait 输出")

## 为什么把fork 和 exec 分开？
从上面的程序看来，如果想创建一个新进程运行程序，直接一个API做完不就行了吗？为什么有fork() 和 exec() 这么"奇怪"的API设计的？事实证明，把fork() 和 exec() 分开是非常必要的设计，特别对于每个Unix版本都带的 shell程序来说，因为把fork() 和 exec() 分开允许shell 在运行目标程序之前对运行环境做修改，从而实现很多有用的功能。

我们知道，shell 程序是一个用户态程序，它会显示一个命令提示符等待用户输入，在用户输入一个可执行命令名称之后，它会fork() 一个子进程，调用 exec() 执行该程序，然后调用 wait() 等待子进程结束。当子进程结束之后，它又显示一个命令提示符等待用户的下一个输入，如此往复。这里我们发现，把fork() 和 exec() 分开可以让我们实现很多实用功能，比如：

    `prompt> wc file > newfile.txt`

在这个例子中，`wc` 的输出被重定向到 `newfile.txt` 中而不是打印到标准输出。shell 程序实现这个功能的方式就是在调用fork() 之后 exec() 之前，先关闭标准输出，然后打开文件 `newfile.txt`，这样子进程的输出就会被重定向到目标文件中。

这里还用了Unix系统文件描述符的一个特性。Unix系统在打开文件的时候会返回一个文件描述符，它会从0开始查找可用的文件描述符。由于先关闭了标准输出的文件描述符，当打开一个新文件的时候，标准输出的文件描述符就会被分配给它。

下图给出了一个简单的代码示例，可以看到在L18关闭了标准输出，L19打开一个文件从而子进程的输出会被写入到文件中。

![fork, exec and wait 输出](/images/ostep_p4_pipe.jpg "fork, exec and wait 输出")

Unix系统的管道也是用类似的方式实现的，区别是它调用了pipe() 函数。pipe() 函数打开两个文件描述符，一个用于输入，一个用于输出，这样就把程序链串起来了。限于长度不再详述了，想要看示例的可以<a href="http://man7.org/tlpi/code/online/diff/pipes/simple_pipe.c.html"> 点击这里 </a>

## 总结
上文主要分析了fork() 和 exec() 的功能，以及为什么设计的时候把它们分开。虽然这两个函数的行为比较“奇葩”，但是它们很有用。这也是系统设计中很重要的一点，先把事情做对，再把它做好。有兴趣的读者可以读读系统设计方面写的很好一篇文章，<a href="http://research.microsoft.com/en-us/um/people/blampson/33-Hints/WebPage.html"> Hints for Computer System Design </a>。

当然除了本文提到的几个重要函数，系统还提供了其他一些很实用的程序，比如kill() 函数用于给进程发信号，用于让进程休眠或者退出等。还有一些很实用的系统命令用于查看进程的状态，比如ps查看正在运行的进程，top查看系统进程占用的资源数据。可以通过man命令来进一步学习。

进程相关的内容已经做了基本的介绍，下篇文章会写操作系统是怎么让CPU合理而且高效地运行这么多进程的。欢迎大家关注我的公众号，有写的不好或者不对的地方请评论指出。谢谢！
