<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Wang Fenjin</title><link>https://www.wangfenjin.com/posts/</link><description>Recent content in Posts on Wang Fenjin</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2023 Wang Fenjin :: Powered by &lt;a href="http://gohugo.io">Hugo&lt;/a></copyright><lastBuildDate>Wed, 26 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.wangfenjin.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>I Am No Longer the Maintainer of duckdb-rs</title><link>https://www.wangfenjin.com/posts/duckdb-rs-moving-forward-en/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.wangfenjin.com/posts/duckdb-rs-moving-forward-en/</guid><description>Background DuckDB is an in-process SQL OLAP database management system implemented in C++. When it was first open-sourced, it was positioned as a columnar database comparable to SQLite, providing the same ease of use. With just a header file and a cpp file, it could be easily embeded in any program, even offering a SQLite-compatible interface, which caught the attention of many people source.
I started paying attention to DuckDB a long time ago and began writing the first line of duckdb-rs code on June 7, 2021.</description><content>&lt;h2 id="background">Background&lt;/h2>
&lt;p>&lt;a href="https://duckdb.org/">DuckDB&lt;/a> is an in-process SQL OLAP database management system implemented in C++. When it was first open-sourced, it was positioned as a columnar database comparable to SQLite, providing the same ease of use. With just a header file and a cpp file, it could be easily embeded in any program, even offering a SQLite-compatible interface, which caught the attention of many people &lt;a href="https://news.ycombinator.com/item?id=24531085">source&lt;/a>.&lt;/p>
&lt;p>I started paying attention to DuckDB a long time ago and began writing the first line of &lt;a href="https://github.com/wangfenjin/duckdb-rs">duckdb-rs&lt;/a> code on June 7, 2021. About a month later, I wrote a &lt;a href="https://www.wangfenjin.com/posts/duckdb-rs/">blog post&lt;/a> introducing the process of building this library, marking the completion of the initial version. Over the past two years, I have released approximately &lt;a href="https://crates.io/crates/duckdb">19 versions&lt;/a>, get more than 200 stars in GitHub.&lt;/p>
&lt;p>In the past year, there have been many requirements and ideas for optimization, but I found myself lacking the time, and the number of received issues has been increasing. As a result, I will transfer this library to &lt;a href="https://github.com/duckdb">DuckDB&lt;/a> offical organization, believing that make duckdb-rs an official client will lead to further progress and bigger success. Also I&amp;rsquo;d like to take this chance to thanks Mark and Hannes for building DuckDB and agree to accept duckdb-rs as the official rust client.&lt;/p>
&lt;p>This blog post summarizes the main tasks I have undertaken during my maintenance period and points out areas that I believe can be improved.&lt;/p>
&lt;h2 id="key-decisions">Key Decisions&lt;/h2>
&lt;p>This library is the Rust client of DuckDB, so the primary audience interested in this library are users who appreciate DuckDB and use the Rust tech stack. Below are some key factors that I consider contributed to the &amp;ldquo;success&amp;rdquo; of this library:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Initial version based on &lt;a href="https://github.com/rusqlite/rusqlite">rusqlite&lt;/a> development. As a Rust beginner myself, I had previously only worked on one Rust project, and this was my second time using Rust. Based on rusqlite, a mature repository, allowed me to quickly obtain a usable version. Additionally, the code structure and API design had already been validated, reducing the likelihood of taking wrong turns. Moreover, the overall code quality could be reasonably assured.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Data exchange based on the &lt;a href="https://github.com/apache/arrow-rs">arrow&lt;/a> format. Arrow is now considered the columnar storage data exchange standard and is used in many open-source projects. DuckDB has good support for arrow as well. Although DuckDB has its native C interface, using the arrow format for data exchange allows relatively stable interactions between Rust and the C API. This approach ensures that we won&amp;rsquo;t need to make frequent changes due to DuckDB iterations, thus reducing maintenance efforts and minimizing the impact of interface changes on users.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Robust CI process. I believe that all open-source projects should strive for this. With a CI process, we can ensure that the code merged into the master branch was error-free. The CI process also included memory leak detection, avoiding potential safety issues introduced by the FFI. The release process was automated as well, with crates being automatically published by tagging.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="notable-mrs">Notable MRs&lt;/h2>
&lt;p>I&amp;rsquo;ve selected a few MRs that I consider significant and that weren&amp;rsquo;t contributed by me:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/1">Add github workflow&lt;/a>: This was the first MR to add CI checks, which was very meaningful as I used to push directly to master before CI was in place.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/32">Add r2d2 connection pool&lt;/a>: This MR added a connection pool, improving the library&amp;rsquo;s performance.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/127">Rework bundled compilation to support included extensions&lt;/a>: This was the largest MR and allowed the library to support extensions, reworking the logic of bundling DuckDB source code to include various extensions without requiring additional installations.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/169">Feat: Develop query polars&lt;/a>: This MR added support for converting query results into polars data structures. &lt;a href="https://github.com/pola-rs/polars">polars&lt;/a> is a popular data processing tool written in Rust. This feature bridged the gap between DuckDB and polars.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Apart from the daily maintenance, I didn&amp;rsquo;t contribute to the development of major features significantly. &lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/138">Support table function&lt;/a> can be considered one, and I believe writing extensions in Rust is simpler and safer compared to C/C++.&lt;/p>
&lt;h2 id="outstanding-issues">Outstanding Issues&lt;/h2>
&lt;p>Due to limited time and resources, there are still some unresolved issues in this library:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Better documentation. Writing documentation has always been a headache for me since English is not my strong suit. While this library inherited some documentation from rusqlite, it lacks ongoing maintenance, especially regarding documentation specific to DuckDB features. Good documentation and blog posts are key to the success of an open-source project.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Support for more data types. There are two categories of data types: those mapped to Rust data types for results, which are not a high priority since arrow-rs already provides comprehensive data types for users working with arrow data. The other category is query parameters, where we need to support a wider range of data types for better user convenience. Currently, we only support some basic query data types.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Improved support for data insertion. Columnar databases require the ability to insert data in batches, such as using DuckDB&amp;rsquo;s built-in append interface or supporting insertion of arrow data.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Compilation process optimization. As DuckDB&amp;rsquo;s features expand, the compilation process for this library has become slower and resource-consuming, resulting in larger build artifacts.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Support for specific DuckDB interfaces, such as streaming query or relation API. These have been raised as issues by some users.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>To achieve the same level as DuckDB in terms of documentation and interfaces, there is still much work to be done.&lt;/p>
&lt;h2 id="future-plans">Future Plans&lt;/h2>
&lt;p>With the publication of this article, it means I am no longer the maintainer of duckdb-rs. However, this does not mean that I will no longer contribute code to duckdb-rs. I will continue to follow DuckDB and duckdb-rs and contribute code in my spare time.&lt;/p>
&lt;p>If I have time, I may also work on other projects based on duckdb-rs, such as:&lt;/p>
&lt;ul>
&lt;li>Creating a Rust extension for DuckDB to become a vector database&lt;/li>
&lt;li>Or building a storage server based on duckdb-rs primarily using the &lt;a href="https://github.com/apache/arrow-rs/tree/master/arrow-flight">arrow-flight&lt;/a> protocol. If I have even more time, I might add support for Raft to enable distribution. I&amp;rsquo;m not sure how useful these projects would be, but they sound like fun.&lt;/li>
&lt;li>Another possibility is creating a distributed data processing tool, using DuckDB as intermediate data storage or for computation acceleration.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;blockquote>
&lt;p>Translated from &lt;a href="https://www.wangfenjin.com/posts/duckdb-rs-moving-forward/">CN Version&lt;/a> using ChatGPT and polished manually.&lt;/p>
&lt;/blockquote></content></item><item><title>我将不再做 duckdb-rs 的维护者</title><link>https://www.wangfenjin.com/posts/duckdb-rs-moving-forward/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.wangfenjin.com/posts/duckdb-rs-moving-forward/</guid><description>背景 DuckDB 是一个 C++ 编写的单机版嵌入式分析型数据库。它刚开源的时候是对标 SQLite 的列存数据库，并提供与 SQLite 一样的易用性，编译成一个头文件和一个 cpp 文件就可以在程序中使用，甚至提供与 SQLite 兼容的接口，因此受到了很多人的关注。
我很久之前就开始关注 DuckDB，并在 2021-06-07 开始写第一行 duckdb-rs 的代码，在 一个多月后写了一篇博客介绍了构建这个库的过程，算是实现了第一个版本。到今天差不多2年的时间，前后发布了19个版本，收获了 200 多个star。
最近一年其实还有很多需求和想法去做优化，但是发现自己并没有那么多时间，收到的 issue 也越来越多。经过沟通，我会把这个库转给 DuckDB 官方来维护，相信 duckdb-rs 一定会发展得越来越好。同时也非常感谢 Mark 和 Hannes 愿意接手这个仓库并把它作为官方的 rust 客户端。
这篇博客总结下我维护的这段时间主要做的事，以及我认为可以改善的点，算是对过去的总结和对未来的憧憬。
关键决策 这个库是 duckdb 的 rust 客户端，所以关注这个库的群体首先是认可 duckdb 的用户，其次因为他们是 rust 技术栈。下面我列举一些我认为是让这个库“成功”的一些关键点。
初始版本基于 rusqlite 开发。因为我也是一个 rust 初学者，之前只拿 rust 做过一个项目，这是第二次使用 rust。基于 rustqlite 这样一个成熟的仓库做改造，能让我很快得到一个可用的版本，快速建立信心；另外整个程序的组织，API 的设计都已经经过了验证，不容易走弯路；整体的代码质量也能有基本保障。 基于 arrow 格式来交换数据。arrow 现在基本上算是列存储的数据交换标准，在很多开源项目中都有使用，duckdb 对 arrow 的支持也比较完善。虽然 duckdb 有自己的原生 C 接口，但是基于 arrow 格式来做数据交换，能让 rust 和 c-api 调用相对稳定，不会因为 duckdb 迭代导致 C 接口的变更，我们也需要一直变更，一定程度上减轻了维护的工作量，也减少了接口变更对用户的影响。 完善的 CI 流程，我认为所有的开源项目都应该要做到这一点。因为继承自 rusqlite，这个库从一开始就有 CI 流程，能保证合并到 master 的代码是没问题的，并且 CI 里面还有关于内存泄漏的检测，避免了 ffi 带了的可能不安全的问题。发布过程也是自动化的，只要打个 tag 就自动发布到 crate。CI 的机制保障了任何感兴趣的人都可以提交 MR 并得到检验，也保证自己如果长时间不维护了不至于都不知道从哪里开始改。 几个 MR 下面我挑选几个我认为比较关键的，并且不是我贡献的 MR：</description><content>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>&lt;a href="https://duckdb.org/">DuckDB&lt;/a> 是一个 C++ 编写的单机版嵌入式分析型数据库。它刚开源的时候是对标 SQLite 的列存数据库，并提供与 SQLite 一样的易用性，编译成一个头文件和一个 cpp 文件就可以在程序中使用，甚至提供与 SQLite 兼容的接口，因此受到了很多人的&lt;a href="https://news.ycombinator.com/item?id=24531085">关注&lt;/a>。&lt;/p>
&lt;p>我很久之前就开始关注 DuckDB，并在 2021-06-07 开始写第一行 &lt;a href="https://github.com/wangfenjin/duckdb-rs">duckdb-rs&lt;/a> 的代码，在 一个多月后写了一篇&lt;a href="https://www.wangfenjin.com/posts/duckdb-rs/">博客&lt;/a>介绍了构建这个库的过程，算是实现了第一个版本。到今天差不多2年的时间，前后发布了&lt;a href="https://crates.io/crates/duckdb">19个版本&lt;/a>，收获了 200 多个star。&lt;/p>
&lt;p>最近一年其实还有很多需求和想法去做优化，但是发现自己并没有那么多时间，收到的 issue 也越来越多。经过沟通，我会把这个库转给 &lt;a href="https://github.com/duckdb">DuckDB&lt;/a> 官方来维护，相信 duckdb-rs 一定会发展得越来越好。同时也非常感谢 Mark 和 Hannes 愿意接手这个仓库并把它作为官方的 rust 客户端。&lt;/p>
&lt;p>这篇博客总结下我维护的这段时间主要做的事，以及我认为可以改善的点，算是对过去的总结和对未来的憧憬。&lt;/p>
&lt;h2 id="关键决策">关键决策&lt;/h2>
&lt;p>这个库是 duckdb 的 rust 客户端，所以关注这个库的群体首先是认可 duckdb 的用户，其次因为他们是 rust 技术栈。下面我列举一些我认为是让这个库“成功”的一些关键点。&lt;/p>
&lt;ol>
&lt;li>初始版本基于 &lt;a href="https://github.com/rusqlite/rusqlite">rusqlite&lt;/a> 开发。因为我也是一个 rust 初学者，之前只拿 rust 做过一个项目，这是第二次使用 rust。基于 rustqlite 这样一个成熟的仓库做改造，能让我很快得到一个可用的版本，快速建立信心；另外整个程序的组织，API 的设计都已经经过了验证，不容易走弯路；整体的代码质量也能有基本保障。&lt;/li>
&lt;li>基于 &lt;a href="https://github.com/apache/arrow-rs">arrow&lt;/a> 格式来交换数据。arrow 现在基本上算是列存储的数据交换标准，在很多开源项目中都有使用，duckdb 对 arrow 的支持也比较完善。虽然 duckdb 有自己的原生 C 接口，但是基于 arrow 格式来做数据交换，能让 rust 和 c-api 调用相对稳定，不会因为 duckdb 迭代导致 C 接口的变更，我们也需要一直变更，一定程度上减轻了维护的工作量，也减少了接口变更对用户的影响。&lt;/li>
&lt;li>完善的 CI 流程，我认为所有的开源项目都应该要做到这一点。因为继承自 rusqlite，这个库从一开始就有 CI 流程，能保证合并到 master 的代码是没问题的，并且 CI 里面还有关于内存泄漏的检测，避免了 ffi 带了的可能不安全的问题。发布过程也是自动化的，只要打个 tag 就自动发布到 crate。CI 的机制保障了任何感兴趣的人都可以提交 MR 并得到检验，也保证自己如果长时间不维护了不至于都不知道从哪里开始改。&lt;/li>
&lt;/ol>
&lt;h2 id="几个-mr">几个 MR&lt;/h2>
&lt;p>下面我挑选几个我认为比较关键的，并且不是我贡献的 MR：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/1">Add github workflow&lt;/a>，之前我都是直接 push master，这是第一个 MR 添加 CI 检测，非常有意义！&lt;/li>
&lt;li>&lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/32">add r2d2 connection pool&lt;/a>，添加连接池。&lt;/li>
&lt;li>&lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/127">Rework bundled compilation to support included extensions&lt;/a>，收到最大的一个 MR，为了支持 extension，重做了 bundle duckdb 源码的逻辑，让这个仓库也能打包进去各种扩展而不用额外安装。&lt;/li>
&lt;li>&lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/169">Feat: Develop query polars&lt;/a>，支持把 query 的结果转成 polars 的数据结构，&lt;a href="https://github.com/pola-rs/polars">polars&lt;/a> 是目前 rust 写的一个非常流行的数据处理工具，这个功能打通了 duckdb 和 polars。&lt;/li>
&lt;/ol>
&lt;p>我自己除了日常维护之外，实际上大的功能开发比较少，&lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/138">Support table function&lt;/a> 算是一个，并且我认为基于 rust 写扩展远比基于 c/c++ 来写更简单，更安全！&lt;/p>
&lt;h2 id="遗留问题">遗留问题&lt;/h2>
&lt;p>因为精力有限，这个库还有一些问题需要解决：&lt;/p>
&lt;ol>
&lt;li>更好的文档。因为我的英语也是半路出家，所以写文档一直是想起来就头疼的问题。这个库因为是基于 rusqlite，所以继承了一部分文档，所以基本质量还在，但是后续缺少维护，特别是针对 duckdb 特性的一些文档资料比较少。好的文档和博客也是开源项目成功的关键。&lt;/li>
&lt;li>支持更多数据类型。这里的数据类型分两类，一类是对于结果，映射到 rust 的数据类型，这部分的需求倒是不高优，特别是用户如果是使用的 arrow 数据的话，arrow-rs 本身有完整的数据类型；另一类是查询参数，这部分需要支持更多的数据类型绑定，方便用户使用。目前我们只支持了一些基础的数据类型。&lt;/li>
&lt;li>更完善的数据插入支持。列存数据库需要有批量插入数据的能力，比如 duckdb 自带的 append 接口，或者支持插入 arrow 的数据等，目前这一块支持得不太好。&lt;/li>
&lt;li>编译过程优化。随着 duckdb 功能丰富，这个库的编译也越来越慢，对资源的消耗也越来越多，编译的产物也越来越大。&lt;/li>
&lt;li>一些 duckdb 或者列存特定的接口支持，比如 streaming query 或者 relation api，这些都有人提过 issue。&lt;/li>
&lt;/ol>
&lt;p>从文档和接口上，要达到和 duckdb 一样的水准，还有不少工作要做。&lt;/p>
&lt;h2 id="后续计划">后续计划&lt;/h2>
&lt;p>这篇文章发布的时候，意味着我不再是 duckdb-rs 的维护者。但是这不代表着后续我不再给 duckdb-rs 贡献代码，我还是会继续关注 duckdb 和 duckdb-rs，并且在闲暇的时候贡献一些代码。&lt;/p>
&lt;p>如果有时间还可以基于 duckdb-rs 做一些其他的项目，比如用 rust 给 duckdb 做一个向量数据库的扩展，或者基于 duckdb-rs 搭建一个存储的 server，主要是基于 &lt;a href="https://github.com/apache/arrow-rs/tree/master/arrow-flight">arrow-flight&lt;/a> 协议，如果再有时间还可以加上 raft 支持分布式。不知道有什么用，但是感觉是个很好玩的项目。也可以考虑做一个分布式数据处理的工具，用 duckdb 做中间数据的存储或者计算加速等。&lt;/p></content></item><item><title>基于 apache-arrow 的 duckdb rust 客户端</title><link>https://www.wangfenjin.com/posts/duckdb-rs/</link><pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.wangfenjin.com/posts/duckdb-rs/</guid><description>背景 duckdb 是一个 C++ 编写的单机版嵌入式分析型数据库。它刚开源的时候是对标 SQLite 的列存数据库，并提供与 SQLite 一样的易用性，编译成一个头文件和一个 cpp 文件就可以在程序中使用，甚至提供与 SQLite 兼容的接口，因此受到了很多人的关注。
本文介绍笔者近期开发的 duckdb-rs 库，让大家可以很方便地在 rust 代码库中使用 duckdb 的功能。
libduckdb-sys 了解过 rust 的同学可能知道，rust 提供了 ffi 的方式与其他语言互通。因为 duckdb 本身是 C++ 编写的，想要在 rust 里面使用 duckdb，就需要考虑 ffi 的问题。而基于 ffi 对其他语言程序封装的基础库，一般会被命名为 libxxx-sys，这也就是 libduckdb-sys 的由来。
为了方便大家使用，duckdb 提供了 C++ 原生接口，C 接口，以及与 SQLite3 兼容的 C 接口。我在做 libduckdb-sys 的时候对这三种接口都尝试过，相关的讨论可以参见 Rust Support，我这里介绍一下当时的情况。
基于 SQLite3 接口 最开始我使用的是 SQLite3 的接口，原因主要有三个：
我对 SQLite 比较熟悉，想必用起来会比较方便； 觉得 SQLite 的接口被广泛使用，接口比较稳定，以后不至于大改； 也许是最重要的一点，市面上已经有 SQLite 的 rust 封装rusqlite，基于 SQLite 的接口应该能最大程度复用 rusqlite 的代码。 尝试之后确实发现很快能把程序跑起来，基本的功能也能使用。但是随着进一步的深入以及对 duckdb 更多的了解，发现了一些弊端：</description><content>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>&lt;a href="https://duckdb.org/">duckdb&lt;/a> 是一个 C++ 编写的单机版嵌入式分析型数据库。它刚开源的时候是对标 SQLite 的列存数据库，并提供与 SQLite 一样的易用性，编译成一个头文件和一个 cpp 文件就可以在程序中使用，甚至提供与 SQLite 兼容的接口，因此受到了很多人的&lt;a href="https://news.ycombinator.com/item?id=24531085">关注&lt;/a>。&lt;/p>
&lt;p>本文介绍笔者近期开发的 duckdb-rs 库，让大家可以很方便地在 rust 代码库中使用 duckdb 的功能。&lt;/p>
&lt;h2 id="libduckdb-sys">libduckdb-sys&lt;/h2>
&lt;p>了解过 rust 的同学可能知道，rust 提供了 &lt;a href="https://doc.rust-lang.org/nomicon/ffi.html">ffi&lt;/a> 的方式与其他语言互通。因为 duckdb 本身是 C++ 编写的，想要在 rust 里面使用 duckdb，就需要考虑 ffi 的问题。而基于 ffi 对其他语言程序封装的基础库，一般会被命名为 libxxx-sys，这也就是 libduckdb-sys 的由来。&lt;/p>
&lt;p>为了方便大家使用，duckdb 提供了 C++ 原生接口，C 接口，以及与 SQLite3 兼容的 C 接口。我在做 libduckdb-sys 的时候对这三种接口都尝试过，相关的讨论可以参见 &lt;a href="https://github.com/duckdb/duckdb/issues/949">Rust Support&lt;/a>，我这里介绍一下当时的情况。&lt;/p>
&lt;h3 id="基于-sqlite3-接口">基于 SQLite3 接口&lt;/h3>
&lt;p>最开始我使用的是 SQLite3 的接口，原因主要有三个：&lt;/p>
&lt;ol>
&lt;li>我对 SQLite 比较熟悉，想必用起来会比较方便；&lt;/li>
&lt;li>觉得 SQLite 的接口被广泛使用，接口比较稳定，以后不至于大改；&lt;/li>
&lt;li>也许是最重要的一点，市面上已经有 SQLite 的 rust 封装&lt;a href="https://github.com/rusqlite/rusqlite">rusqlite&lt;/a>，基于 SQLite 的接口应该能最大程度复用 rusqlite 的代码。&lt;/li>
&lt;/ol>
&lt;p>尝试之后确实发现很快能把程序跑起来，基本的功能也能使用。但是随着进一步的深入以及对 duckdb 更多的了解，发现了一些弊端：&lt;/p>
&lt;ol>
&lt;li>虽说 duckdb 是想最大程度兼容 SQLite，但是毕竟一个是行存一个是列存，有区别在所难免，接口肯定也没办法做到 100% 兼容；&lt;/li>
&lt;li>有一个区别需要特别提出来，SQLite 是&lt;a href="https://www.sqlite.org/datatype3.html">动态数据类型&lt;/a>，而 duckdb 是静态类型，也就是说在 SQLite 中你可以认为所有的数据都是存成 Text，在读取的时候根据 schema 来解析数据；而 duckdb 是会根据数据类型来存储数据，并且根据列存的特性做一些存储优化。有了这个区别之后，如果我们使用 SQLite 的接口的话，会做一些不必要的数据格式转换，性能有损，程序也不直观。&lt;/li>
&lt;li>duckdb 可以被编译成一个 so 使用，如果想使用 SQLite 的接口，需要再编译一个 sqlite3_api_wrapper 出来，两个库合作才能使用 SQLite 的接口，这给程序分发引入了额外的负担；另外目前 duckdb 在 release 的时候没有自带 sqlite3_api_wrapper，需要用户自己去编译，使用上又多了一些不便。&lt;/li>
&lt;li>由于上面的封装的问题，数据类型的问题，以及通过 SQLite 接口查询 duckdb 的数据时候，结果集会被复制一遍，资源占用必定上升。&lt;/li>
&lt;/ol>
&lt;p>基于上面一些原因，我最终放弃了基于 SQLite 接口来开发，转而尝试使用原生的 C++ 或者 C 接口。&lt;/p>
&lt;h3 id="基于-c-接口">基于 C++ 接口&lt;/h3>
&lt;p>既然为了性能和接口丰富性，使用 C++ 接口当然是首选，毕竟 duckdb 本身主要都是拿 C++ 开发的，duckdb 的 &lt;a href="https://github.com/duckdb/duckdb/tree/master/tools/pythonpkg">python 封装&lt;/a> 也是拿 C++ 接口来做的。&lt;/p>
&lt;p>市面上也有方便 rust 与 C++ 交互的一些代码库，比如 &lt;a href="https://github.com/dtolnay/cxx">cxx&lt;/a> 和 &lt;a href="https://github.com/google/autocxx">autocxx&lt;/a>。其中 autocxx 入手门槛低使用上更简单，而 cxx 的可定制性更强，功能更丰富。在尝试了几次之后发现了一些问题，主要还是 rust ffi 只能支持部分的 C++ 语法，大部分情况下可能是够用的，但是对于 duckdb 这样比较大型的数据库代码，还是有很多不支持的地方。除非自己再基于现有的 C++ 接口封装一份支持 cxx 的版本，否则就算这一次编译过了，也很难保证以后 duckdb 的作者以后不会引入其他的特性导致不能兼容。&lt;/p>
&lt;p>而 rust 基于 C 语言的 ffi 是原生支持的，所以最终还是下定决心基于 C 接口来开发。&lt;/p>
&lt;h3 id="基于-c-接口-1">基于 C 接口&lt;/h3>
&lt;p>因为有 rusqlite 作为参考，所以很快实现了基于 C 接口的版本。简单来说，主要是通过 &lt;a href="https://github.com/eqrion/cbindgen">cbindgen&lt;/a>、&lt;a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build.rs&lt;/a> 和 rust 的 &lt;a href="https://doc.rust-lang.org/cargo/reference/features.html">features&lt;/a> 功能来实现。其中：&lt;/p>
&lt;ul>
&lt;li>cbindgen 用于生成基于 C 接口的 rust 代码，方便 rust 其他程序使用&lt;/li>
&lt;li>build.rs 和 features 用于控制整个编译流程，用户可以根据需要是当场编译依赖库，还是使用机器上已经安装好的版本&lt;/li>
&lt;li>build.rs 中还可以选择使用 &lt;a href="https://crates.io/crates/cc">cc&lt;/a> 来实时编译 duckdb 实现，这样其他使用 rust 封装的人不用关心 duckdb 的安装问题&lt;/li>
&lt;/ul>
&lt;p>应该说这是一个很通用的提供 C 接口 rust 封装的解决方案，感兴趣的同学可以 &lt;a href="https://github.com/wangfenjin/duckdb-rs/tree/main/libduckdb-sys">参考&lt;/a>。&lt;/p>
&lt;h2 id="duckdb-rs">duckdb-rs&lt;/h2>
&lt;p>完成了 libduckdb-sys 之后其实只是第一步，因为这样生成的代码都是 unsafe 代码，具体的使用例子可以参考 &lt;a href="https://github.com/wangfenjin/duckdb-rs/blob/main/libduckdb-sys/src/lib.rs">lib.rs&lt;/a> 中的测试代码。但是我们使用 rust 主要是为了他的安全性，rust 希望我们尽量减少 unsafe 的使用。所以一般的 rust 封装都会基于 libxxx-sys 提供一个内存安全的版本，这就是 duckdb-rs 的部分。&lt;/p>
&lt;h3 id="小试牛刀">小试牛刀&lt;/h3>
&lt;p>还是因为有 rusqlite 的参考，所以花了一些时间终于实现了最初始的版本，并且我已经把这个版本发布到 &lt;a href="https://crates.io/crates/duckdb">crates.io&lt;/a> 上了。这个版本的目标是基于 rusqlite 做最小的改动，并删掉 SQLite 特有的功能，让整个程序跑起来。完成之后效果不错，下面是文档中给的一个使用范例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> duckdb::{params, Connection, Result};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[derive(Debug)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: Option&lt;span style="color:#f92672">&amp;lt;&lt;/span>Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> conn &lt;span style="color:#f92672">=&lt;/span> Connection::open_in_memory()&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conn.execute_batch(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">r&lt;/span>&lt;span style="color:#e6db74">&amp;#34;CREATE SEQUENCE seq;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> CREATE TABLE person (
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> id INTEGER PRIMARY KEY DEFAULT NEXTVAL(&amp;#39;seq&amp;#39;),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> name TEXT NOT NULL,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> data BLOB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> );
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> me &lt;span style="color:#f92672">=&lt;/span> Person {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="color:#e6db74">&amp;#34;Steven&amp;#34;&lt;/span>.to_string(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: None,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conn.execute(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;INSERT INTO person (name, data) VALUES (?, ?)&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> params![me.name, me.data],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> stmt &lt;span style="color:#f92672">=&lt;/span> conn.prepare(&lt;span style="color:#e6db74">&amp;#34;SELECT id, name, data FROM person&amp;#34;&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> person_iter &lt;span style="color:#f92672">=&lt;/span> stmt.query_map([], &lt;span style="color:#f92672">|&lt;/span>row&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(Person {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: &lt;span style="color:#a6e22e">row&lt;/span>.get(&lt;span style="color:#ae81ff">0&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="color:#a6e22e">row&lt;/span>.get(&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: &lt;span style="color:#a6e22e">row&lt;/span>.get(&lt;span style="color:#ae81ff">2&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> person &lt;span style="color:#66d9ef">in&lt;/span> person_iter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;Found person &lt;/span>&lt;span style="color:#e6db74">{:?}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, person.unwrap());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，接口设计非常优雅，代码也非常符合 rust 的风格，使用上也非常方便。实现过程中发现有些 duckdb 的 C 接口还不支持的部分，我也通过提 issue 或者 PR 去解决了。这里必须要提一点，duckdb 的维护者非常耐心，不管是回答问题还是 review 代码都非常专业。&lt;/p>
&lt;p>剩下的问题有一个是之前提到的，duckdb 是静态类型的数据，所以需要支持很多数据类型，这里面工作量不小。另外，因为我之前也有关注 &lt;a href="https://arrow.apache.org/">Apache Arrow&lt;/a>，做过 OLAP 数据库的同学可能知道，Apache Arrow 是一个通用的列式内存格式，方便在内存中做大数据量的计算或者传输，有很多 OLAP 数据引擎都在用。刚好 duckdb 也支持 arrow 格式，所以就想尝试使用 arrow 格式来查询数据，这样至少有两个好处，一个是这样我们就可以暴露 arrow 格式的数据给用户，在使用的时候就可以用上 arrow 生态的其他功能，有可能会产生一些化学反应；另外 arrow 也是有丰富的数据类型和明确的定义，反正我们是要支持很多数据类型的，现在的 C 接口本身也不完善，用 arrow 格式反而更加清晰。&lt;/p>
&lt;h3 id="通过-apache-arrow-查询数据">通过 Apache Arrow 查询数据&lt;/h3>
&lt;p>基于上面的考虑，我把目标又看向了 &lt;a href="https://github.com/apache/arrow-rs">arrow-rs&lt;/a>，并给 duckdb 的 C 接口也加上了 &lt;a href="https://github.com/duckdb/duckdb/pull/1978">arrow 的功能&lt;/a>，最终在 duckdb-rs 中实现了通过 Arrow 格式来查询数据，实现参见 &lt;a href="https://github.com/wangfenjin/duckdb-rs/pull/8">这里&lt;/a>。&lt;/p>
&lt;p>实现之后，之前通过行来读取数据的接口完全不变，还能直接查询到 Arrow 格式的数据，下面是一个测试的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">test_query_arrow_record_batch_large&lt;/span>() -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> db &lt;span style="color:#f92672">=&lt;/span> Connection::open_in_memory().unwrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.execute_batch(&lt;span style="color:#e6db74">&amp;#34;BEGIN TRANSACTION&amp;#34;&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.execute_batch(&lt;span style="color:#e6db74">&amp;#34;CREATE TABLE test(t INTEGER);&amp;#34;&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> _ &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#ae81ff">300&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.execute_batch(&lt;span style="color:#e6db74">&amp;#34;INSERT INTO test VALUES (1); INSERT INTO test VALUES (2); INSERT INTO test VALUES (3); INSERT INTO test VALUES (4); INSERT INTO test VALUES (5);&amp;#34;&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.execute_batch(&lt;span style="color:#e6db74">&amp;#34;END TRANSACTION&amp;#34;&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> rbs &lt;span style="color:#f92672">=&lt;/span> db.query_arrow(&lt;span style="color:#e6db74">&amp;#34;select t from test order by t&amp;#34;&lt;/span>, [])&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert_eq!(rbs.len(), &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert_eq!(rbs.iter().map(&lt;span style="color:#f92672">|&lt;/span>rb&lt;span style="color:#f92672">|&lt;/span> rb.num_rows()).sum::&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">usize&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(), &lt;span style="color:#ae81ff">1500&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert_eq!(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rbs.iter()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map(&lt;span style="color:#f92672">|&lt;/span>rb&lt;span style="color:#f92672">|&lt;/span> rb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .column(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .as_any()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .downcast_ref::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Int32Array&lt;span style="color:#f92672">&amp;gt;&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .unwrap()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .iter()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map(&lt;span style="color:#f92672">|&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> i.unwrap())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .sum::&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">i32&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .sum::&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">i32&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4500&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，我们查询到 Arrow 格式的数据之后，还能通过 arrow-rs 中提供的其他能力做进一步的计算，十分方便。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文主要介绍了 duckdb-rs 的设计和实现，笔者之前有一些开发 OLAP 数据的经验，但是对于 rust 算是新手，之前虽然写过一些但是没有深入学习，做这个项目也有一个目的是为了重新学习一下 rust。好在有 rusqlite 作为参考，所以没有碰到特别多语言层面的问题。&lt;/p>
&lt;p>希望这篇文章对于其他对 rust 和数据库感兴趣的同学有一些帮助。同时这个库还有很多没解决的问题，比如支持更多的数据类型，支持连接池，支持更快的数据导入接口等等，我已经建了一些 issues，感兴趣的同学可以回复 &lt;a href="https://github.com/wangfenjin/duckdb-rs/issues">issue&lt;/a> 认领，我也会竭力提供需要的帮助，大家一起讨论和学习。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>duckdb 的官网：https://duckdb.org/&lt;/li>
&lt;li>duckdb 的代码库：https://github.com/duckdb/duckdb&lt;/li>
&lt;li>SQLite 的 rust 封装，duckdb-rs 也是基于它改的：https://github.com/rusqlite/rusqlite&lt;/li>
&lt;li>duckdb-rs 的代码库：https://github.com/wangfenjin/duckdb-rs&lt;/li>
&lt;li>Apache Arrow 的 rust 实现：https://github.com/apache/arrow-rs&lt;/li>
&lt;/ul></content></item><item><title>Simple: SQLite3 结巴分词插件</title><link>https://www.wangfenjin.com/posts/simple-jieba-tokenizer/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.wangfenjin.com/posts/simple-jieba-tokenizer/</guid><description>一年前开发 simple 分词器，实现了微信在两篇文章中描述的，基于 SQLite 支持中文和拼音的搜索方案。具体背景参见这篇文章。项目发布后受到了一些朋友的关注，后续也发布了一些改进，提升了项目易用性。
最近重新体验微信客户端搜索功能，发现对于中文的搜索已经不是基于单字命中，而是更精准的基于词组。比如搜索“法国”，之前如果句子中有“法”和“国”两个字时也会命中，所以如果一句话里包含“国法”就会被命中，但是这跟“法国”没有任何关系。
本文描述对 simple 分词器添加的基于词组命中的实现，从而实现更好的查找效果。另外本文也会基于之前在 issue 中大家提到的问题，提供一个怎么使用 SQLite FTS 表的建议。
背景 先简单回顾一下之前的实现，因为结巴分词只跟中文有关，所以本文会略去拼音的部分。
搜索主要分为两部分，建立索引和命中索引。为了实现中文的搜索，我们先把句子按照单字拆分，按照单字建立索引；然后对于用户的输入，也同样按照单字拆分，这样 query 就能命中索引了。为了支持词组搜索，再按照单字拆分就很难满足需求了，所以可以考虑的方案是要么改索引，要么改 query。如果改索引的话会有一些问题，比如如果用户就输入了一个字比如“国”，但是我们建索引的时候把“法国”放到了一起，那“国”字就命中不了了，所以最好是保持单字索引不变，通过改写 query 来达到检索词组的效果。
实现 simple 分词器之前提供了一个 simple_query() 函数来帮助用户生成 query，我们也可以加一个新的函数来实现词组的功能。经过简单的调研，我们发现 cppjieba 用 C++ 实现了结巴分词的功能，很适用与我们的需求。
所以我实现了一个新的函数叫做 jieba_query() ，它的使用方式跟 simple_query() 一样，内部实现时，我们会先使用 cppjieba 对输入进行分词，再根据分词的结果构建 SQLite3 能理解的 query ，从而实现了词组匹配的功能。具体的逻辑可以参考 这里 。对于不需要结巴分词功能的用户，可以在编译的时候使用 -DSIMPLE_WITH_JIEBA=OFF 关闭结巴分词的功能，这样能减少编译文件的大小，方便客户端对文件大小敏感的场景使用。
使用 本文想着重介绍一下 SQLite3 FTS5 功能使用的问题，这些问题都是有朋友在项目的 issue 中提到过的，都是非常好的问题，但是也说明有不少人对怎么使用 FTS 表不太清楚，希望本文能解决一些疑惑。
首先第一点，FTS5 表虽然是一个虚拟表，提供了全文搜索的功能，但是它整体还是跳不出 SQL 的范畴，所以其实很多用法和其他 SQL 表是一样的，当然它也跳不出 SQL 的限制。比如有一个 issue 问如果表中有多列的时候，能不能检索全表，但是只返回命中的那些列？答案是不行的，因为按照 SQL 的语法规则，SELECT 语句后面必须显示说明你想要 SELECT 哪些列，所以结果列是必须用户指定的，如果我们像知道哪些列命中了，只能通过其他一些手段，感兴趣的朋友可以看这个 issue36。</description><content>&lt;p>一年前开发 simple 分词器，实现了微信在两篇文章中描述的，基于 SQLite 支持中文和拼音的搜索方案。具体背景参见&lt;a href="https://www.wangfenjin.com/posts/simple-tokenizer/">这篇文章&lt;/a>。项目发布后受到了一些朋友的关注，后续也发布了一些改进，提升了项目易用性。&lt;/p>
&lt;p>最近重新体验微信客户端搜索功能，发现对于中文的搜索已经不是基于单字命中，而是更精准的基于词组。比如搜索“法国”，之前如果句子中有“法”和“国”两个字时也会命中，所以如果一句话里包含“国法”就会被命中，但是这跟“法国”没有任何关系。&lt;/p>
&lt;p>本文描述对 simple 分词器添加的基于词组命中的实现，从而实现更好的查找效果。另外本文也会基于之前在 issue 中大家提到的问题，提供一个怎么使用 SQLite FTS 表的建议。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>先简单回顾一下之前的实现，因为结巴分词只跟中文有关，所以本文会略去拼音的部分。&lt;/p>
&lt;p>搜索主要分为两部分，建立索引和命中索引。为了实现中文的搜索，我们先把句子按照单字拆分，按照单字建立索引；然后对于用户的输入，也同样按照单字拆分，这样 query 就能命中索引了。为了支持词组搜索，再按照单字拆分就很难满足需求了，所以可以考虑的方案是要么改索引，要么改 query。如果改索引的话会有一些问题，比如如果用户就输入了一个字比如“国”，但是我们建索引的时候把“法国”放到了一起，那“国”字就命中不了了，所以最好是保持单字索引不变，通过改写 query 来达到检索词组的效果。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>simple 分词器之前提供了一个 simple_query() 函数来帮助用户生成 query，我们也可以加一个新的函数来实现词组的功能。经过简单的调研，我们发现 &lt;a href="https://github.com/yanyiwu/cppjieba">cppjieba&lt;/a> 用 C++ 实现了结巴分词的功能，很适用与我们的需求。&lt;/p>
&lt;p>所以我实现了一个新的函数叫做 jieba_query() ，它的使用方式跟 simple_query() 一样，内部实现时，我们会先使用 cppjieba 对输入进行分词，再根据分词的结果构建 SQLite3 能理解的 query ，从而实现了词组匹配的功能。具体的逻辑可以参考 &lt;a href="https://github.com/wangfenjin/simple/pull/35">这里&lt;/a> 。对于不需要结巴分词功能的用户，可以在编译的时候使用 &lt;code>-DSIMPLE_WITH_JIEBA=OFF&lt;/code> 关闭结巴分词的功能，这样能减少编译文件的大小，方便客户端对文件大小敏感的场景使用。&lt;/p>
&lt;h2 id="使用">使用&lt;/h2>
&lt;p>本文想着重介绍一下 SQLite3 FTS5 功能使用的问题，这些问题都是有朋友在项目的 issue 中提到过的，都是非常好的问题，但是也说明有不少人对怎么使用 FTS 表不太清楚，希望本文能解决一些疑惑。&lt;/p>
&lt;p>首先第一点，FTS5 表虽然是一个虚拟表，提供了全文搜索的功能，但是它整体还是跳不出 SQL 的范畴，所以其实很多用法和其他 SQL 表是一样的，当然它也跳不出 SQL 的限制。比如有一个 issue 问如果表中有多列的时候，能不能检索全表，但是只返回命中的那些列？答案是不行的，因为按照 SQL 的语法规则，SELECT 语句后面必须显示说明你想要 SELECT 哪些列，所以结果列是必须用户指定的，如果我们像知道哪些列命中了，只能通过其他一些手段，感兴趣的朋友可以看这个 &lt;a href="https://github.com/wangfenjin/simple/issues/36">issue36&lt;/a>。&lt;/p>
&lt;p>另外 simple 分词器提供了不少额外的功能，比如 simple_query() 和 simple_highlight() 等辅助函数，但是它并不影响我们使用原有 FTS5 的功能，比如如果想按照相关度排序，FTS5 自带的 &lt;code>order by rank&lt;/code> 功能还是可以继续可以使用，也就是说 &lt;a href="https://www.sqlite.org/fts5.html">FTS5 页面&lt;/a> 提供的所有功能都是可以和 simple 分词器一起使用的。&lt;/p>
&lt;p>最后也是最重要的一个问题，FTS5 表到底该怎么用？有一个 &lt;a href="https://github.com/wangfenjin/simple/issues/26">issue26&lt;/a> 提到的问题非常好，我把它放到这里：&lt;/p>
&lt;blockquote>
&lt;p>《微信全文搜索优化之路》一文中针对索引表的介绍，我对索引有几个问题想请教一下：&lt;/p>
&lt;ol>
&lt;li>业务表是正常的程序的数据表，还要再为了全文搜索再多建立一份索引表，是吗？我直接将我的业务数据表在创建的时候按虚表建立行吗？（例如create virtual table tablename using fts5(列名1,列名2,tokenize = &amp;lsquo;simple&amp;rsquo;)）&lt;/li>
&lt;li>如果再多建立一份索引表，那是不是每一个业务表和对应的索引表的表字段是完全相同？&lt;/li>
&lt;li>如果再多建立一份索引表，那数据库的大小是不是加倍了，尤其是把文件或图片影片存入数据库的情况（BLOB类型）？&lt;/li>
&lt;li>原文中【为了解决业务变化而带来的表结构修改问题，微信把业务属性数字化】，这也是我想要的，能否帮助贴下原文中提到的【索引表-IndexTable】和【数据表-MetaTable】的建表语句？&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>核心的问题是：想让表数据支持全文搜索，需要把数据复制一份吗？这样会不会导致数据库膨胀？在用户的手机上我们可不想占用太多无谓的空间。&lt;/p>
&lt;h3 id="externel-content-table">externel content table&lt;/h3>
&lt;p>其实这个问题在 FTS5 的官方文档中已经给出了解决方案那就是 &lt;a href="https://www.sqlite.org/fts5.html#external_content_and_contentless_tables">externel content table&lt;/a>，大家也可以参考 &lt;a href="https://kimsereylam.com/sqlite/2020/03/06/full-text-search-with-sqlite.html">这篇文章&lt;/a> 。&lt;/p>
&lt;p>它的意思是我们可以建一张普通表，然后再建一张 FTS5 表来支持全文索引，这张虚拟表本身不会存储真实的数据，如果 SELECT 语句用到具体的内容，都会通过关联关系去原表获取，这样就不存在数据重复的问题了。但是这里就会涉及到数据一致性的问题，怎么保证原表的数据和索引表是一致的呢？通过 trigger 也就是触发器来实现：对于原表的增删改，都会通过触发器同步到 FTS 表。这样基本上就完美解决了上面用户的问题。&lt;/p>
&lt;p>可能有人会问为什么不直接用 FTS5 表呢？这样普通表就不用了，也省了触发器的逻辑。原因是 FTS 表提供了全文索引的能力，但是它也有限制，对于基于 ID 或者其他普通索引的请求它是不支持的，如果我们想有一个时间列并且基于时间列索引排序，FTS表就不行，还是需要普通表。通过普通表和 FTS 表结合的方案，我们就能同时使用两者的能力。&lt;/p>
&lt;h3 id="微信的方案">微信的方案&lt;/h3>
&lt;p>需要注意的是，微信并没有使用上面提到的方案，而是单独建了一张打平的索引表，把所有需要全文索引的数据放到一张单独的表里面，再通过外键关联到具体的业务去。这样的好处在微信的文章中有所提及，主要是其他关联的表结构变更的时候，FTS 表不用动，这样很容易添加想要搜索的字段，只需把该字段写入 FTS 表及关联关系的表就行，表结构见下图：&lt;/p>
&lt;p>&lt;img src="https://www.wangfenjin.com/img/wechat-fts5.jpeg" alt="wechat-fts5">&lt;/p>
&lt;p>个人觉得对于微信这个复杂度的业务，可以考虑这个方案，毕竟需要搜索的信息非常多，这样方便各个业务复用搜索能力。但是对于大部分的业务，用 external content table 可能是更简单的方案，毕竟在数据写入和读取的时候都更快更方便，微信的方案在数据操作流程上会复杂不少，需要逻辑上做更多的封装。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>上面主要介绍了 simple 分词器最新的功能，基于结巴分词实现基于词组的搜索功能，实现更精准的匹配。另外也介绍了在实际项目中使用 FTS 表的方案，希望对大家有所助益。&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>Simple 分词器: &lt;a href="https://github.com/wangfenjin/simple">https://github.com/wangfenjin/simple&lt;/a>&lt;/li>
&lt;li>sqlite 官方文档：&lt;a href="https://www.sqlite.org/fts5.html">https://www.sqlite.org/fts5.html&lt;/a>&lt;/li>
&lt;li>微信全文搜索优化之路：&lt;a href="https://cloud.tencent.com/developer/article/1006159">https://cloud.tencent.com/developer/article/1006159&lt;/a>&lt;/li>
&lt;li>微信移动端的全文检索多音字问题解决方案：&lt;a href="https://cloud.tencent.com/developer/article/1198371">https://cloud.tencent.com/developer/article/1198371&lt;/a>&lt;/li>
&lt;li>Simple: 一个支持中文和拼音搜索的 sqlite fts5插件：&lt;a href="https://www.wangfenjin.com/posts/simple-tokenizer/">https://www.wangfenjin.com/posts/simple-tokenizer/&lt;/a>&lt;/li>
&lt;li>Full Text Search With Sqlite SQLite：&lt;a href="https://kimsereylam.com/sqlite/2020/03/06/full-text-search-with-sqlite.html">https://kimsereylam.com/sqlite/2020/03/06/full-text-search-with-sqlite.html&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>xeus-clickhouse: Jupyter 的 ClickHouse 内核</title><link>https://www.wangfenjin.com/posts/jupyter-clickhouse/</link><pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate><guid>https://www.wangfenjin.com/posts/jupyter-clickhouse/</guid><description>在科学计算领域，Jupyter 是一个使用非常广泛的集成开发环境，它支持多种主流的编程语言比如 Python, C++, R 或者 Julia。同时，数据科学最重要的还是数据，而 SQL 是操作数据最直观的语言。前段时间看到一篇文章，有人给 sqlite 做了一个 jupyter 的内核，感觉很有意思。所以我尝试给 ClickHouse 做了一个 jupyter 的内核，目前已经有了一个可以试用的版本，下面做一个简单介绍。
现状 新内核允许用户用 ClickHouse SQL 的语法直接操作远程 CH 数据库，通过一些扩展操作比如 %CONNECT 支持与 ch cli 一样的连接参数，后续也有计划使用 jupyter magics 支持更多的数据可视化操作。
项目参考了 jupyter sqlite 内核的实现方式，是基于 xeus 框架来实现的。xeus 是一个 c++ 的 lib 库，它对 jupyter 的内核做了很好的封装，我们只需要专注于内核相关的功能就可以了。目前对于 ch 的操作基于 clickhouse-cpp 来实现，它是 ch 的 cpp 客户端。
目前实现处于早期阶段，但是基础功能已经可用。它支持了几乎 CH 所有 SQL 语法，具体例子可以参考 clickhouse.ipynb。xeus-clickhouse 在 jupyter notebook 和 jupyter lab 中以 HTML 表格的形式展示数据；在 jupyter console 中，我们使用 tabulate 库只做纯文本的表格。</description><content>&lt;p>在科学计算领域，Jupyter 是一个使用非常广泛的集成开发环境，它支持多种主流的编程语言比如 Python, C++, R 或者 Julia。同时，数据科学最重要的还是数据，而 SQL 是操作数据最直观的语言。前段时间看到&lt;a href="https://blog.jupyter.org/a-jupyter-kernel-for-sqlite-9549c5dcf551">一篇文章&lt;/a>，有人给 sqlite 做了一个 jupyter 的内核，感觉很有意思。所以我尝试给 ClickHouse 做了一个 jupyter 的内核，目前已经有了一个可以试用的版本，下面做一个简单介绍。&lt;/p>
&lt;h2 id="现状">现状&lt;/h2>
&lt;p>新内核允许用户用 ClickHouse SQL 的语法直接操作远程 CH 数据库，通过一些扩展操作比如 &lt;code>%CONNECT&lt;/code> 支持与 ch cli 一样的连接参数，后续也有计划使用 jupyter magics 支持更多的数据可视化操作。&lt;/p>
&lt;p>项目参考了 jupyter sqlite 内核的实现方式，是基于 &lt;a href="https://github.com/jupyter-xeus/xeus">xeus&lt;/a> 框架来实现的。xeus 是一个 c++ 的 lib 库，它对 jupyter 的内核做了很好的封装，我们只需要专注于内核相关的功能就可以了。目前对于 ch 的操作基于 clickhouse-cpp 来实现，它是 ch 的 cpp 客户端。&lt;/p>
&lt;p>&lt;img src="https://www.wangfenjin.com/img/ch-sql.gif" alt="ch-sql">&lt;/p>
&lt;p>目前实现处于早期阶段，但是基础功能已经可用。它支持了几乎 CH 所有 SQL 语法，具体例子可以参考 &lt;a href="https://github.com/wangfenjin/xeus-clickhouse/blob/master/examples/clickhouse.ipynb">clickhouse.ipynb&lt;/a>。xeus-clickhouse 在 jupyter notebook 和 jupyter lab 中以 HTML 表格的形式展示数据；在 jupyter console 中，我们使用 tabulate 库只做纯文本的表格。&lt;/p>
&lt;h2 id="未来">未来&lt;/h2>
&lt;p>对于 xeus-clickhouse 未来的规划是，先打磨好稳定性，目前已知的还有一个非法字符导致内核崩溃的问题，已经提交 issue 给 xeus 仓库；另外clickhouse-cpp 不支持 ssl 连接。除了基础功能的打磨，还计划通过支持更多的 jupyter magic 来实现数据的可视化渲染，提供更方便的数据可视化能力。&lt;/p>
&lt;h2 id="使用">使用&lt;/h2>
&lt;p>我制作了一个 Docker 镜像发布在 &lt;a href="https://hub.docker.com/r/wangfenjin/xeus-clickhouse">docker-hub&lt;/a>，不需要安装任何环境就可以试用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># start jupyter with clickhouse kernal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -p 8888:8888 wangfenjin/xeus-clickhouse:v0.1.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># start a local clickhouse for testing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name jupyter-clickhouse-server -p 8123:8123 --ulimit nofile&lt;span style="color:#f92672">=&lt;/span>262144:262144 yandex/clickhouse-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># open the example/clickhouse.ipynb and connect to local server by &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %CONNECT --host host.docker.internal --port 8123&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 docker 里面连接另外一个 docker 中的 ch 可能会有问题，感觉是目前 clickhouse-cpp 对于网络的处理不太完善。感兴趣的同学也可以下载代码自己编译，具体的编译流程见 &lt;a href="https://github.com/wangfenjin/xeus-clickhouse">github&lt;/a> 仓库。欢迎大家试用！&lt;/p></content></item><item><title>用 od 查看 ClickHouse 的索引文件</title><link>https://www.wangfenjin.com/posts/clickhouse-od/</link><pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate><guid>https://www.wangfenjin.com/posts/clickhouse-od/</guid><description>背景 学习 ClickHouse (后面简称 CH) 的时候，会对 CH 到底怎么组织磁盘上的 MergeTree 文件有很多疑惑。关于 MergeTree 的介绍可以参考[1]，但是如果想具体看下磁盘上的文件，没有现成的工具。本文参考 [2] 介绍通过 od 查看磁盘文件的方法，感兴趣的话可以自己试一下，会对 MergeTree 有更深的理解。
本文以 官方Tutorial 中的 hits_v1 表为例来说明。下面主要描述怎么看 primary.idx 文件和 [column].mrk 文件。在 MergeTree 数据结构中，primary.idx 可认为是一级索引，mrk 文件是用作定位具体文件偏移量的，他们的行数是相同且一一对应。
查看 primary.idx primary.idx 里面的文件是把主键的索引写入到磁盘文件中，hits_v1 的主键为 order by 语句中的字段，即 ORDER BY (CounterID, EventDate, intHash32(UserID))，CounterID 类型是 uint32，存储为4字节；EventDate 类型是 Date，存储是 2字节整型；intHash32 是4字节整型。CH 的文件内容非常紧凑，每个字段是紧挨着写入的，没有其他类似空格符等浪费。所以 primary.idx 的存储格式是 4+2+4，然后每隔 8192 行写一行索引。查看内容的方法为：
# sql 选择第一行索引的内容 Select CounterID,toRelativeDayNum(EventDate),intHash32(UserID) from tutorial.hits_v1 limit 0,1; # od 查看 3 个字段 od -An -i -j 0 -N 4 primary.</description><content>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>学习 ClickHouse (后面简称 CH) 的时候，会对 CH 到底怎么组织磁盘上的 MergeTree 文件有很多疑惑。关于 MergeTree 的介绍可以参考[1]，但是如果想具体看下磁盘上的文件，没有现成的工具。本文参考 [2] 介绍通过 od 查看磁盘文件的方法，感兴趣的话可以自己试一下，会对 MergeTree 有更深的理解。&lt;/p>
&lt;p>本文以 &lt;a href="https://clickhouse.tech/docs/en/getting_started/tutorial/">官方Tutorial&lt;/a> 中的 hits_v1 表为例来说明。下面主要描述怎么看 primary.idx 文件和 [column].mrk 文件。在 MergeTree 数据结构中，primary.idx 可认为是一级索引，mrk 文件是用作定位具体文件偏移量的，他们的行数是相同且一一对应。&lt;/p>
&lt;h2 id="查看-primaryidx">查看 primary.idx&lt;/h2>
&lt;p>primary.idx 里面的文件是把主键的索引写入到磁盘文件中，hits_v1 的主键为 order by 语句中的字段，即 &lt;code>ORDER BY (CounterID, EventDate, intHash32(UserID))&lt;/code>，CounterID 类型是 uint32，存储为4字节；EventDate 类型是 Date，存储是 2字节整型；intHash32 是4字节整型。CH 的文件内容非常紧凑，每个字段是紧挨着写入的，没有其他类似空格符等浪费。所以 primary.idx 的存储格式是 4+2+4，然后每隔 8192 行写一行索引。查看内容的方法为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># sql 选择第一行索引的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Select CounterID,toRelativeDayNum&lt;span style="color:#f92672">(&lt;/span>EventDate&lt;span style="color:#f92672">)&lt;/span>,intHash32&lt;span style="color:#f92672">(&lt;/span>UserID&lt;span style="color:#f92672">)&lt;/span> from tutorial.hits_v1 limit 0,1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># od 查看 3 个字段&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>od -An -i -j &lt;span style="color:#ae81ff">0&lt;/span> -N &lt;span style="color:#ae81ff">4&lt;/span> primary.idx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>od -An -i -j &lt;span style="color:#ae81ff">4&lt;/span> -N &lt;span style="color:#ae81ff">2&lt;/span> primary.idx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>od -An -i -j &lt;span style="color:#ae81ff">6&lt;/span> -N &lt;span style="color:#ae81ff">4&lt;/span> primary.idx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 类似的，sql 选择第二行索引的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Select CounterID,toRelativeDayNum&lt;span style="color:#f92672">(&lt;/span>EventDate&lt;span style="color:#f92672">)&lt;/span>,intHash32&lt;span style="color:#f92672">(&lt;/span>UserID&lt;span style="color:#f92672">)&lt;/span> from tutorial.hits_v1 limit 8192,1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># od 查看 3 个字段&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>od -An -i -j &lt;span style="color:#ae81ff">10&lt;/span> -N &lt;span style="color:#ae81ff">4&lt;/span> primary.idx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>od -An -i -j &lt;span style="color:#ae81ff">14&lt;/span> -N &lt;span style="color:#ae81ff">2&lt;/span> primary.idx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>od -An -i -j &lt;span style="color:#ae81ff">16&lt;/span> -N &lt;span style="color:#ae81ff">4&lt;/span> primary.idx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于 od 的选项介绍如下：&lt;/p>
&lt;ul>
&lt;li>-An 是不让输出偏移只输出文本内容&lt;/li>
&lt;li>-i 是说把选择的位当作长度为 4 的整型输出；对于 EventDate 虽然存储的是 2， 但是我们把它当作 4 位输出也没问题，主要控制在 -j -N&lt;/li>
&lt;li>-j 偏移的起始字节数&lt;/li>
&lt;li>-N 从偏移量开始读取的字节数&lt;/li>
&lt;/ul>
&lt;p>-A,-j, -N 这几个选项是必须有的，-i 得看数据类型是啥，还支持其他的比如字符、浮点类型等&lt;/p>
&lt;p>从上面可以看到，想查看 primary.idx 的文件，需要知道主键的排列顺序和主键的类型，没办法像 parquet tools 一样很简单地写一个通用程序来直接查看文件。&lt;/p>
&lt;h2 id="查看-columnmrk">查看 [column].mrk&lt;/h2>
&lt;p>mrk 文件是辅助定位 bin 文件设置的。bin 文件被分成小的数据块，每个数据块压缩后存放到一起。可以参考从 [1] 中的截图：
&lt;img src="https://www.wangfenjin.com/img/ch-bin.jpeg" alt="ch-bin-file">&lt;/p>
&lt;p>mrk 文件行数与 idx 文件一致，每行包含两个固定为 8 字节的整型，第一个整型是 [column].bin 文件的偏移量定位到具体的数据块，第二个整型是把数据块解压后定位解压后的文件偏移。查看 mrk 的脚本如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -z &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$1&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;Missing filename, mrk.sh file.mrk&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filename&lt;span style="color:#f92672">=&lt;/span>$1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>len&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>wc -c &amp;lt; $filename&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>offset&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>maxline&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#66d9ef">$((&lt;/span>len/16&lt;span style="color:#66d9ef">))&lt;/span> -gt $maxline &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$filename&lt;span style="color:#e6db74"> first &lt;/span>$maxline&lt;span style="color:#e6db74"> lines:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$filename&lt;span style="color:#e6db74"> content:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#66d9ef">$((&lt;/span>offset+16&lt;span style="color:#66d9ef">))&lt;/span> -le $len &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $maxline -gt &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>od -An -t d8 -j $offset -N &lt;span style="color:#ae81ff">8&lt;/span> $filename&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>od -An -t d8 -j &lt;span style="color:#66d9ef">$((&lt;/span>offset+8&lt;span style="color:#66d9ef">))&lt;/span> -N &lt;span style="color:#ae81ff">8&lt;/span> $filename&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $line
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$((&lt;/span>$offset&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#66d9ef">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxline&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$((&lt;/span>$maxline&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看 mrk 文件的脚本是通用的，传入文件名就可以了。它的正确性也是可以验证的，比如对于 UserID 这个字段，它是 uint64 型，即占用 8 个字节，8192 行就是 65536 个字节；刚好 bin 文件中数据块的默认最小值是 65536，所以会发现 UserID.mrk 文件第二列的值永远为 0，因为刚好解压缩后的偏移量是 0。&lt;/p>
&lt;p>对于 CounterID.mrk 文件，它是 int32 占用 4 个字节，所以能看到第二列的值是可能出现非 0 的。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>CH 没有提供简单的方案查看 idx 和 mrk 文件的内容，我们可以通过 od 来模拟实现，能帮助我们更好了解 MergeTree 这个数据结构。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>朱凯老师关于 MergeTree 的介绍：https://github.com/ClickHouse/clickhouse-presentations/blob/master/meetup32/朱凯.ppt&lt;/li>
&lt;li>一个俄语的 PPT 提到 od 的使用，想自己看 PPT 的话可以用 Google 翻译：https://github.com/ClickHouse/clickhouse-presentations/blob/master/meetup27/adaptive_index_granularity.pdf&lt;/li>
&lt;/ol></content></item><item><title>Spacemacs Intro</title><link>https://www.wangfenjin.com/posts/spacemacs-intro/</link><pubDate>Thu, 12 Mar 2020 00:00:00 +0000</pubDate><guid>https://www.wangfenjin.com/posts/spacemacs-intro/</guid><description>Intro video: https://www.ixigua.com/i6803300850765660676/
What&amp;rsquo;s spacemacs?
A emacs configuration framework Support both emacs and vim editing styles Great programming tool Project management: SPC+p projectile
SPC+p+p SPC+p+f SPC+p+t Search: SPC+s ripgrep
SPC+* SPC+/ SPC+s+s Navigation: lsp
Code: gd, SPC+j+i Buffer: SPC+b Window: SPC+w, ALT+num SPC+a Editing: vim evil
Version Control: magit Shell: SPC+' eshell
Help: SPC+?, SPC+h</description><content>&lt;p>Intro video: &lt;a href="https://www.ixigua.com/i6803300850765660676/">https://www.ixigua.com/i6803300850765660676/&lt;/a>&lt;/p>
&lt;p>What&amp;rsquo;s spacemacs?&lt;/p>
&lt;ol>
&lt;li>A emacs configuration framework&lt;/li>
&lt;li>Support both emacs and vim editing styles&lt;/li>
&lt;li>Great programming tool&lt;/li>
&lt;/ol>
&lt;h2 id="project-management-spcp">Project management: SPC+p&lt;/h2>
&lt;p>projectile&lt;/p>
&lt;ol>
&lt;li>SPC+p+p&lt;/li>
&lt;li>SPC+p+f&lt;/li>
&lt;li>SPC+p+t&lt;/li>
&lt;/ol>
&lt;h2 id="search-spcs">Search: SPC+s&lt;/h2>
&lt;p>ripgrep&lt;/p>
&lt;ol>
&lt;li>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SPC+*&lt;/li>
&lt;li>SPC+/&lt;/li>
&lt;li>SPC+s+s&lt;/li>
&lt;/ol>
&lt;h2 id="navigation">Navigation:&lt;/h2>
&lt;p>lsp&lt;/p>
&lt;ol>
&lt;li>Code: gd, SPC+j+i&lt;/li>
&lt;li>Buffer: SPC+b&lt;/li>
&lt;li>Window: SPC+w, ALT+num&lt;/li>
&lt;li>SPC+a&lt;/li>
&lt;/ol>
&lt;h2 id="editing-vim">Editing: vim&lt;/h2>
&lt;p>evil&lt;/p>
&lt;h2 id="version-control-magit">Version Control: magit&lt;/h2>
&lt;h2 id="shell-spc">Shell: SPC+'&lt;/h2>
&lt;p>eshell&lt;/p>
&lt;h2 id="help-spc-spch">Help: SPC+?, SPC+h&lt;/h2></content></item><item><title>Simple: 一个支持中文和拼音搜索的 sqlite fts5插件</title><link>https://www.wangfenjin.com/posts/simple-tokenizer/</link><pubDate>Sun, 08 Mar 2020 00:00:00 +0000</pubDate><guid>https://www.wangfenjin.com/posts/simple-tokenizer/</guid><description>之前的工作关系，需要在手机上支持中文和拼音搜索。由于手机上存储数据一般都是用 sqlite，所以是基于 sqlite3 fts5 来实现。这段时间再次入门 c++，所以想用 c++ 实现一下，一来用于练手，二来当时做的时候发现网络上这方面开源的实现不多，也造福下其他人。
背景 搜索现在几乎是每个 APP 必备的功能，用户已经习惯了搜索框搜一下，避免到处去找。搜索也是帮助用户查找旧信息，发现新功能的一个重要手段。平常我们用微信的时候经常会搜索联系人和聊天记录，发现微信这一块做的还是非常好的。关于微信的全文搜索，可以看看这两篇文章：微信全文搜索优化之路 和 微信移动端的全文检索多音字问题解决方案 。
第一篇文章主要是问题和原理的概述，第二篇文章是核心分词器的实现。我写的这个项目主要是实现了 simple 分词器，并提供一些辅助函数帮助使用。
Simple 分词器 搜索的核心是建倒排索引，建索引的核心是分词器。 跟名字一下，Simple 分词器的规则非常简单：
空白符跳过 连续的数字作为整体是一个索引 连续的英文字母作为整体并转换成小写索引 中文字单独建索引，并且把中文字转成拼音后也建搜索，这样就能同时支持中文和拼音检索。另外把拼音首字母也建索引，这样搜索 zjl 就能命中 &amp;ldquo;周杰伦&amp;rdquo;。 其他字符统一单独建索引，这样搜索 😊 也能搜到 上面的 5 条都比较好理解，关于中文为什么这么做（而不是连续的中文一起建索引），是由于客户端搜索的需求决定的。具体可以参考上面微信的两篇文章。
有了上面的规则，代码写起来就很简单了，核心逻辑 30 行就解决了。这块代码运行效率也比较高，一遍扫描 O(n) 的复杂度就完成了分词操作。
query 拆分 索引建好之后，query 需要根据分词规则来写才能查询到数据。比如根据上面的逻辑：
如果查数字，我们要把搜索词当作前缀来用，比如用户搜索 123， query 就需要换成 123*，这样如果索引里面有 12345 也能被搜索出来 对于英文，除了要当作前缀，还需要把搜索词转成小写，比如用护搜索 Hello，query 就需要换成 hello*, 这样如果索引里面有 HelloWorld 也能被命中 对于中文和其他字符，都要拆成单个的才能命中索引 最后对于拼音（其实我们没办法区分英文和拼音，统一当作拼音处理就行），需要把拼音按照规则拆分，因为我们的拼音索引是单字建立的。这样如果用户搜索 &amp;ldquo;zhangliangy&amp;rdquo;，拼音就可以被拆成 &amp;lsquo;zhang AND liang AND y*&amp;rsquo;，从而命中&amp;quot;张靓颖&amp;quot;。具体规则微信的文章中也有详述。 可以看到 query 词重构的逻辑也比较多，在之前的项目中没有好的办法，所以是自己在应用层代码里面组装好了 query 再给 sqlite 去搜的，这样其实不太方便。在这个项目中，我实现了一个 simple_query 的字符串函数，输入一个 string，它会给转换成组装好的搜索词，用法跟使用 sqlite 内置函数一样，这样就方便很多了，下面是一个例子：</description><content>&lt;p>之前的工作关系，需要在手机上支持中文和拼音搜索。由于手机上存储数据一般都是用 sqlite，所以是基于 sqlite3 fts5 来实现。这段时间再次入门 c++，所以想用 c++ 实现一下，一来用于练手，二来当时做的时候发现网络上这方面开源的实现不多，也造福下其他人。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>搜索现在几乎是每个 APP 必备的功能，用户已经习惯了搜索框搜一下，避免到处去找。搜索也是帮助用户查找旧信息，发现新功能的一个重要手段。平常我们用微信的时候经常会搜索联系人和聊天记录，发现微信这一块做的还是非常好的。关于微信的全文搜索，可以看看这两篇文章：&lt;a href="https://juejin.im/entry/59e6cd266fb9a0451968ab02">微信全文搜索优化之路&lt;/a> 和 &lt;a href="https://cloud.tencent.com/developer/article/1198371">微信移动端的全文检索多音字问题解决方案&lt;/a> 。&lt;/p>
&lt;p>第一篇文章主要是问题和原理的概述，第二篇文章是核心分词器的实现。我写的这个项目主要是实现了 simple 分词器，并提供一些辅助函数帮助使用。&lt;/p>
&lt;h2 id="simple-分词器">Simple 分词器&lt;/h2>
&lt;p>搜索的核心是建倒排索引，建索引的核心是分词器。 跟名字一下，Simple 分词器的规则非常简单：&lt;/p>
&lt;ol>
&lt;li>空白符跳过&lt;/li>
&lt;li>连续的数字作为整体是一个索引&lt;/li>
&lt;li>连续的英文字母作为整体并转换成小写索引&lt;/li>
&lt;li>中文字单独建索引，并且把中文字转成拼音后也建搜索，这样就能同时支持中文和拼音检索。另外把拼音首字母也建索引，这样搜索 zjl 就能命中 &amp;ldquo;周杰伦&amp;rdquo;。&lt;/li>
&lt;li>其他字符统一单独建索引，这样搜索 😊 也能搜到&lt;/li>
&lt;/ol>
&lt;p>上面的 5 条都比较好理解，关于中文为什么这么做（而不是连续的中文一起建索引），是由于客户端搜索的需求决定的。具体可以参考上面微信的两篇文章。&lt;/p>
&lt;p>有了上面的规则，代码写起来就很简单了，&lt;a href="https://github.com/wangfenjin/simple/blob/a9234eb7169d98522ff07f42e0e9f9aa603bbebd/src/simple_tokenizer.cc#L104">核心逻辑&lt;/a> 30 行就解决了。这块代码运行效率也比较高，一遍扫描 O(n) 的复杂度就完成了分词操作。&lt;/p>
&lt;h2 id="query-拆分">query 拆分&lt;/h2>
&lt;p>索引建好之后，query 需要根据分词规则来写才能查询到数据。比如根据上面的逻辑：&lt;/p>
&lt;ol>
&lt;li>如果查数字，我们要把搜索词当作前缀来用，比如用户搜索 123， query 就需要换成 123*，这样如果索引里面有 12345 也能被搜索出来&lt;/li>
&lt;li>对于英文，除了要当作前缀，还需要把搜索词转成小写，比如用护搜索 Hello，query 就需要换成 hello*, 这样如果索引里面有 HelloWorld 也能被命中&lt;/li>
&lt;li>对于中文和其他字符，都要拆成单个的才能命中索引&lt;/li>
&lt;li>最后对于拼音（其实我们没办法区分英文和拼音，统一当作拼音处理就行），需要把拼音按照规则拆分，因为我们的拼音索引是单字建立的。这样如果用户搜索 &amp;ldquo;zhangliangy&amp;rdquo;，拼音就可以被拆成 &amp;lsquo;zhang AND liang AND y*&amp;rsquo;，从而命中&amp;quot;张靓颖&amp;quot;。具体规则微信的文章中也有详述。&lt;/li>
&lt;/ol>
&lt;p>可以看到 query 词重构的逻辑也比较多，在之前的项目中没有好的办法，所以是自己在应用层代码里面组装好了 query 再给 sqlite 去搜的，这样其实不太方便。在这个项目中，我实现了一个 simple_query 的字符串函数，输入一个 string，它会给转换成组装好的搜索词，用法跟使用 sqlite 内置函数一样，这样就方便很多了，下面是一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 完整例子：https://github.com/wangfenjin/simple/blob/master/test.sql
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- load so file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>.&lt;span style="color:#66d9ef">load&lt;/span> libsimple.so
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- set tokenize to simple
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> VIRTUAL &lt;span style="color:#66d9ef">TABLE&lt;/span> t1 &lt;span style="color:#66d9ef">USING&lt;/span> fts5(x, tokenize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;simple&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- add some values into the table
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">insert&lt;/span> &lt;span style="color:#66d9ef">into&lt;/span> t1 &lt;span style="color:#66d9ef">values&lt;/span> (&lt;span style="color:#e6db74">&amp;#34;周杰伦 Jay Chou:最美的不是下雨天，是曾与你躲过雨的屋檐&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- query result: [周杰伦] Jay Chou:最美的不是下雨天，是曾与你躲过雨的屋檐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">select&lt;/span> simple_highlight(t1, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;[&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;]&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">from&lt;/span> t1 &lt;span style="color:#66d9ef">where&lt;/span> x &lt;span style="color:#66d9ef">match&lt;/span> simple_query(&lt;span style="color:#e6db74">&amp;#39;zhoujiel&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到， match 后面用 simple_query 这个函数，传入用户输入的搜索词就可以用了。&lt;/p>
&lt;p>另外 sql 中还有一个 simple_highlight 函数，它的作用和内置的 highlight 函数一样，只是它会把连续命中的词一起高亮。比如对于文档&amp;quot;周杰伦&amp;quot;，如果搜索词是 &amp;lsquo;zhou AND jie&amp;rsquo;，那么 highlight 函数会返回 &amp;ldquo;[周][杰]伦&amp;rdquo;，simple_highlight 会返回 &amp;ldquo;[周杰]伦&amp;rdquo;。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>最后说几句关于 sqlite fts5 的使用的问题。个人建议通过 trigger 的方式来维护索引的这张表，具体使用的方式可以在官方文章中搜索 trigger 找到例子。这样使用的好处是没有复杂的逻辑去保证文档数据和索引数据一致，微信的文章中很大一部分复杂度在描述怎么保证数据一致的问题。他们可能有自己的业务复杂性，但是对于一般的场景来说， trigger 是最好的方式。&lt;/p>
&lt;p>从这个项目我们能学到：&lt;/p>
&lt;ol>
&lt;li>怎么给 sqlite3 做一个支持中文和拼音的 fts5 拓展&lt;/li>
&lt;li>怎么给 sqlite3 添加用户自定义的函数&lt;/li>
&lt;li>在一个项目中同时使用 c 和 c++ ，并合理处理边界问题&lt;/li>
&lt;/ol>
&lt;p>大家可以下载使用，也可以根据自己的需求去改进，定制更多的函数和策略。&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>Simple 分词器: &lt;a href="https://github.com/wangfenjin/simple">https://github.com/wangfenjin/simple&lt;/a>&lt;/li>
&lt;li>sqlite 官方文档：&lt;a href="https://www.sqlite.org/fts5.html">https://www.sqlite.org/fts5.html&lt;/a>&lt;/li>
&lt;li>微信全文搜索优化之路：&lt;a href="https://juejin.im/entry/59e6cd266fb9a0451968ab02">https://juejin.im/entry/59e6cd266fb9a0451968ab02&lt;/a>&lt;/li>
&lt;li>微信移动端的全文检索多音字问题解决方案：&lt;a href="https://cloud.tencent.com/developer/article/1198371">https://cloud.tencent.com/developer/article/1198371&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Showcase</title><link>https://www.wangfenjin.com/posts/my-first-post/</link><pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.wangfenjin.com/posts/my-first-post/</guid><description>Header 2 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam nec interdum metus. Aenean rutrum ligula sodales ex auctor, sed tempus dui mollis. Curabitur ipsum dui, aliquet nec commodo at, tristique eget ante. Donec quis dolor nec nunc mollis interdum vel in purus. Sed vitae leo scelerisque, sollicitudin elit sed, congue ante. In augue nisl, vestibulum commodo est a, tristique porttitor est. Proin laoreet iaculis ornare. Nullam ut neque quam.</description><content>&lt;h2 id="header-2">Header 2&lt;/h2>
&lt;p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam nec interdum metus. Aenean rutrum ligula sodales ex auctor, sed tempus dui mollis. Curabitur ipsum dui, aliquet nec commodo at, tristique eget ante. &lt;strong>Donec quis dolor nec nunc mollis interdum vel in purus&lt;/strong>. Sed vitae leo scelerisque, sollicitudin elit sed, congue ante. In augue nisl, vestibulum commodo est a, tristique porttitor est. Proin laoreet iaculis ornare. Nullam ut neque quam.&lt;/p>
&lt;blockquote>
&lt;p>Fusce pharetra suscipit orci nec tempor. Quisque vitae sem sit amet sem mollis consequat. Sed at imperdiet lorem. Vestibulum pharetra faucibus odio, ac feugiat tellus sollicitudin at. Pellentesque varius tristique mi imperdiet dapibus. Duis orci odio, sodales lacinia venenatis sit amet, feugiat et diam.&lt;/p>
&lt;/blockquote>
&lt;h3 id="header-3">Header 3&lt;/h3>
&lt;p>Nulla libero turpis, lacinia vitae cursus ut, auctor dictum nisl. Fusce varius felis nec sem ullamcorper, at convallis nisi vestibulum. Duis risus odio, porta sit amet placerat mollis, tincidunt non mauris. Suspendisse fringilla, &lt;code>odio a dignissim pharetra&lt;/code>, est urna sollicitudin urna, eu scelerisque magna ex vitae tellus.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* PostCSS code */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">pre&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">background&lt;/span>: &lt;span style="color:#ae81ff">#1a1a1d&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">padding&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">border-radius&lt;/span>: &lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">font-size&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">rem&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">overflow&lt;/span>: &lt;span style="color:#66d9ef">auto&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">@media&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(--phone)&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">white-space&lt;/span>: &lt;span style="color:#66d9ef">pre-wrap&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">word-wrap&lt;/span>: &lt;span style="color:#66d9ef">break-word&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">code&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">background&lt;/span>: &lt;span style="color:#66d9ef">none&lt;/span> &lt;span style="color:#75715e">!important&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">color&lt;/span>: &lt;span style="color:#ae81ff">#ccc&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">padding&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">font-size&lt;/span>: &lt;span style="color:#66d9ef">inherit&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// JS code
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">menuTrigger&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">querySelector&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;.menu-trigger&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">menu&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">querySelector&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;.menu&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">mobileQuery&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getComputedStyle&lt;/span>(document.&lt;span style="color:#a6e22e">body&lt;/span>).&lt;span style="color:#a6e22e">getPropertyValue&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;--phoneWidth&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">isMobile&lt;/span> &lt;span style="color:#f92672">=&lt;/span> () =&amp;gt; window.&lt;span style="color:#a6e22e">matchMedia&lt;/span>(&lt;span style="color:#a6e22e">mobileQuery&lt;/span>).&lt;span style="color:#a6e22e">matches&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">isMobileMenu&lt;/span> &lt;span style="color:#f92672">=&lt;/span> () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">menuTrigger&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">toggle&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;hidden&amp;#39;&lt;/span>, &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">isMobile&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">menu&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">toggle&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;hidden&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">isMobile&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">isMobileMenu&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">menuTrigger&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;click&amp;#39;&lt;/span>, () =&amp;gt; &lt;span style="color:#a6e22e">menu&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">toggle&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;hidden&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>window.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;resize&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">isMobileMenu&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- HTML code --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">section&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;main&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">h1&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;title&amp;#34;&lt;/span>&amp;gt;{{ .Title }}&amp;lt;/&lt;span style="color:#f92672">h1&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ range .Pages }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ .Render &amp;#34;summary&amp;#34;}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ end }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">section&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="header-4">Header 4&lt;/h4>
&lt;p>Curabitur scelerisque felis viverra varius scelerisque. Ut enim libero, molestie gravida blandit at, mollis ornare tellus. Cras arcu mi, ultrices vel pulvinar vel, volutpat eu tortor. Nullam nec eros quis massa ultrices iaculis sed in metus. Praesent sollicitudin sem sit amet orci tempor gravida.&lt;/p>
&lt;ul>
&lt;li>Maecenas elementum vitae nibh vitae porttitor.&lt;/li>
&lt;li>Aenean consequat, risus ut cursus placerat, arcu nulla sodales risus, ut molestie tellus tellus et dui.&lt;/li>
&lt;li>Integer imperdiet turpis vitae lacus imperdiet, ut ornare ligula auctor. Integer in mi eu velit vehicula suscipit eget vulputate nulla.&lt;/li>
&lt;li>Etiam vitae enim quis velit lobortis placerat a ut sem.
&lt;ul>
&lt;li>Curabitur lobortis ante sit amet orci pulvinar, sollicitudin viverra nunc accumsan.&lt;/li>
&lt;li>Praesent fermentum orci quis leo facilisis posuere.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Aliquam erat volutpat. In hac habitasse platea dictumst. Nunc ut tincidunt mauris. Sed at gravida risus, id semper magna. Nullam vitae enim mattis, sodales neque non, pharetra elit. Cras sit amet sagittis augue, et finibus turpis. Ut tempus tincidunt diam vel pharetra. Nulla porttitor odio sit amet nulla scelerisque, quis aliquam mi imperdiet. Sed tincidunt dui vel tellus vestibulum rhoncus. Donec tempus ultrices velit.&lt;/p></content></item></channel></rss>