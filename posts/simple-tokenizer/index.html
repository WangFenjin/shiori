<!doctype html><html lang=en><head><title>Simple: 一个支持中文和拼音搜索的 sqlite fts5插件 :: Wang Fenjin — Software Engineer at Bytedance</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="之前的工作关系，需要在手机上支持中文和拼音搜索。由于手机上存储数据一般都是用 sqlite，所以是基于 sqlite3 fts5 来实现。这段时间再次入门 c++，所以想用 c++ 实现一下，一来用于练手，二来当时做的时候发现网络上这方面开源的实现不多，也造福下其他人。
背景 搜索现在几乎是每个 APP 必备的功能，用户已经习惯了搜索框搜一下，避免到处去找。搜索也是帮助用户查找旧信息，发现新功能的一个重要手段。平常我们用微信的时候经常会搜索联系人和聊天记录，发现微信这一块做的还是非常好的。关于微信的全文搜索，可以看看这两篇文章：微信全文搜索优化之路 和 微信移动端的全文检索多音字问题解决方案 。
第一篇文章主要是问题和原理的概述，第二篇文章是核心分词器的实现。我写的这个项目主要是实现了 simple 分词器，并提供一些辅助函数帮助使用。
Simple 分词器 搜索的核心是建倒排索引，建索引的核心是分词器。 跟名字一下，Simple 分词器的规则非常简单：
 空白符跳过 连续的数字作为整体是一个索引 连续的英文字母作为整体并转换成小写索引 中文字单独建索引，并且把中文字转成拼音后也建搜索，这样就能同时支持中文和拼音检索。另外把拼音首字母也建索引，这样搜索 zjl 就能命中 &amp;ldquo;周杰伦&amp;rdquo;。 其他字符统一单独建索引，这样搜索 😊 也能搜到  上面的 5 条都比较好理解，关于中文为什么这么做（而不是连续的中文一起建索引），是由于客户端搜索的需求决定的。具体可以参考上面微信的两篇文章。
有了上面的规则，代码写起来就很简单了，核心逻辑 30 行就解决了。这块代码运行效率也比较高，一遍扫描 O(n) 的复杂度就完成了分词操作。
query 拆分 索引建好之后，query 需要根据分词规则来写才能查询到数据。比如根据上面的逻辑：
 如果查数字，我们要把搜索词当作前缀来用，比如用户搜索 123， query 就需要换成 123*，这样如果索引里面有 12345 也能被搜索出来 对于英文，除了要当作前缀，还需要把搜索词转成小写，比如用护搜索 Hello，query 就需要换成 hello*, 这样如果索引里面有 HelloWorld 也能被命中 对于中文和其他字符，都要拆成单个的才能命中索引 最后对于拼音（其实我们没办法区分英文和拼音，统一当作拼音处理就行），需要把拼音按照规则拆分，因为我们的拼音索引是单字建立的。这样如果用户搜索 &amp;ldquo;zhangliangy&amp;rdquo;，拼音就可以被拆成 &amp;lsquo;zhang AND liang AND y*'，从而命中&amp;quot;张靓颖&amp;rdquo;。具体规则微信的文章中也有详述。  可以看到 query 词重构的逻辑也比较多，在之前的项目中没有好的办法，所以是自己在应用层代码里面组装好了 query 再给 sqlite 去搜的，这样其实不太方便。在这个项目中，我实现了一个 simple_query 的字符串函数，输入一个 string，它会给转换成组装好的搜索词，用法跟使用 sqlite 内置函数一样，这样就方便很多了，下面是一个例子："><meta name=keywords content="sqlite3,fst5,search,cpp"><meta name=robots content="noodp"><link rel=canonical href=https://www.wangfenjin.com/posts/simple-tokenizer/><link rel=stylesheet href=https://www.wangfenjin.com/assets/style.css><link rel=stylesheet href=https://www.wangfenjin.com/assets/green.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://www.wangfenjin.com/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://www.wangfenjin.com/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:title content="Simple: 一个支持中文和拼音搜索的 sqlite fts5插件 :: Wang Fenjin — Software Engineer at Bytedance"><meta name=twitter:description content="之前的工作关系，需要在手机上支持中文和拼音搜索。由于手机上存储数据一般都是用 sqlite，所以是基于 sqlite3 fts5 来实现。这段时间再次入门 c++，所以想用 c++ 实现一下，一来用于练手，二来当时做的时候发现网络上这方面开源的实现不多，也造福下其他人。
背景 搜索现在几乎是每个 APP 必备的功能，用户已经习惯了搜索框搜一下，避免到处去找。搜索也是帮助用户查找旧信息，发现新功能的一个重要手段。平常我们用微信的时候经常会搜索联系人和聊天记录，发现微信这一块做的还是非常好的。关于微信的全文搜索，可以看看这两篇文章：微信全文搜索优化之路 和 微信移动端的全文检索多音字问题解决方案 。
第一篇文章主要是问题和原理的概述，第二篇文章是核心分词器的实现。我写的这个项目主要是实现了 simple 分词器，并提供一些辅助函数帮助使用。
Simple 分词器 搜索的核心是建倒排索引，建索引的核心是分词器。 跟名字一下，Simple 分词器的规则非常简单：
 空白符跳过 连续的数字作为整体是一个索引 连续的英文字母作为整体并转换成小写索引 中文字单独建索引，并且把中文字转成拼音后也建搜索，这样就能同时支持中文和拼音检索。另外把拼音首字母也建索引，这样搜索 zjl 就能命中 &amp;ldquo;周杰伦&amp;rdquo;。 其他字符统一单独建索引，这样搜索 😊 也能搜到  上面的 5 条都比较好理解，关于中文为什么这么做（而不是连续的中文一起建索引），是由于客户端搜索的需求决定的。具体可以参考上面微信的两篇文章。
有了上面的规则，代码写起来就很简单了，核心逻辑 30 行就解决了。这块代码运行效率也比较高，一遍扫描 O(n) 的复杂度就完成了分词操作。
query 拆分 索引建好之后，query 需要根据分词规则来写才能查询到数据。比如根据上面的逻辑：
 如果查数字，我们要把搜索词当作前缀来用，比如用户搜索 123， query 就需要换成 123*，这样如果索引里面有 12345 也能被搜索出来 对于英文，除了要当作前缀，还需要把搜索词转成小写，比如用护搜索 Hello，query 就需要换成 hello*, 这样如果索引里面有 HelloWorld 也能被命中 对于中文和其他字符，都要拆成单个的才能命中索引 最后对于拼音（其实我们没办法区分英文和拼音，统一当作拼音处理就行），需要把拼音按照规则拆分，因为我们的拼音索引是单字建立的。这样如果用户搜索 &amp;ldquo;zhangliangy&amp;rdquo;，拼音就可以被拆成 &amp;lsquo;zhang AND liang AND y*'，从而命中&amp;quot;张靓颖&amp;rdquo;。具体规则微信的文章中也有详述。  可以看到 query 词重构的逻辑也比较多，在之前的项目中没有好的办法，所以是自己在应用层代码里面组装好了 query 再给 sqlite 去搜的，这样其实不太方便。在这个项目中，我实现了一个 simple_query 的字符串函数，输入一个 string，它会给转换成组装好的搜索词，用法跟使用 sqlite 内置函数一样，这样就方便很多了，下面是一个例子："><meta name=twitter:site content="https://www.wangfenjin.com"><meta name=twitter:creator content="Wang Fenjin"><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Simple: 一个支持中文和拼音搜索的 sqlite fts5插件 :: Wang Fenjin — Software Engineer at Bytedance"><meta property="og:description" content="之前的工作关系，需要在手机上支持中文和拼音搜索。由于手机上存储数据一般都是用 sqlite，所以是基于 sqlite3 fts5 来实现。这段时间再次入门 c++，所以想用 c++ 实现一下，一来用于练手，二来当时做的时候发现网络上这方面开源的实现不多，也造福下其他人。
背景 搜索现在几乎是每个 APP 必备的功能，用户已经习惯了搜索框搜一下，避免到处去找。搜索也是帮助用户查找旧信息，发现新功能的一个重要手段。平常我们用微信的时候经常会搜索联系人和聊天记录，发现微信这一块做的还是非常好的。关于微信的全文搜索，可以看看这两篇文章：微信全文搜索优化之路 和 微信移动端的全文检索多音字问题解决方案 。
第一篇文章主要是问题和原理的概述，第二篇文章是核心分词器的实现。我写的这个项目主要是实现了 simple 分词器，并提供一些辅助函数帮助使用。
Simple 分词器 搜索的核心是建倒排索引，建索引的核心是分词器。 跟名字一下，Simple 分词器的规则非常简单：
 空白符跳过 连续的数字作为整体是一个索引 连续的英文字母作为整体并转换成小写索引 中文字单独建索引，并且把中文字转成拼音后也建搜索，这样就能同时支持中文和拼音检索。另外把拼音首字母也建索引，这样搜索 zjl 就能命中 &amp;ldquo;周杰伦&amp;rdquo;。 其他字符统一单独建索引，这样搜索 😊 也能搜到  上面的 5 条都比较好理解，关于中文为什么这么做（而不是连续的中文一起建索引），是由于客户端搜索的需求决定的。具体可以参考上面微信的两篇文章。
有了上面的规则，代码写起来就很简单了，核心逻辑 30 行就解决了。这块代码运行效率也比较高，一遍扫描 O(n) 的复杂度就完成了分词操作。
query 拆分 索引建好之后，query 需要根据分词规则来写才能查询到数据。比如根据上面的逻辑：
 如果查数字，我们要把搜索词当作前缀来用，比如用户搜索 123， query 就需要换成 123*，这样如果索引里面有 12345 也能被搜索出来 对于英文，除了要当作前缀，还需要把搜索词转成小写，比如用护搜索 Hello，query 就需要换成 hello*, 这样如果索引里面有 HelloWorld 也能被命中 对于中文和其他字符，都要拆成单个的才能命中索引 最后对于拼音（其实我们没办法区分英文和拼音，统一当作拼音处理就行），需要把拼音按照规则拆分，因为我们的拼音索引是单字建立的。这样如果用户搜索 &amp;ldquo;zhangliangy&amp;rdquo;，拼音就可以被拆成 &amp;lsquo;zhang AND liang AND y*'，从而命中&amp;quot;张靓颖&amp;rdquo;。具体规则微信的文章中也有详述。  可以看到 query 词重构的逻辑也比较多，在之前的项目中没有好的办法，所以是自己在应用层代码里面组装好了 query 再给 sqlite 去搜的，这样其实不太方便。在这个项目中，我实现了一个 simple_query 的字符串函数，输入一个 string，它会给转换成组装好的搜索词，用法跟使用 sqlite 内置函数一样，这样就方便很多了，下面是一个例子："><meta property="og:url" content="https://www.wangfenjin.com/posts/simple-tokenizer/"><meta property="og:site_name" content="Simple: 一个支持中文和拼音搜索的 sqlite fts5插件"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2020-03-08 00:00:00 +0000 UTC"></head><body><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Wang Fenjin's Blog</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/about>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/about>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://www.wangfenjin.com/posts/simple-tokenizer/>Simple: 一个支持中文和拼音搜索的 sqlite fts5插件</a></h1><div class=post-meta><span class=post-date>2020-03-08</span>
<span class=post-author>::
Wang Fenjin</span></div><span class=post-tags>#<a href=https://www.wangfenjin.com/tags/sqlite3/>sqlite3</a>&nbsp;
#<a href=https://www.wangfenjin.com/tags/fst5/>fst5</a>&nbsp;
#<a href=https://www.wangfenjin.com/tags/search/>search</a>&nbsp;
#<a href=https://www.wangfenjin.com/tags/cpp/>cpp</a>&nbsp;</span><div class=post-content><div><p>之前的工作关系，需要在手机上支持中文和拼音搜索。由于手机上存储数据一般都是用 sqlite，所以是基于 sqlite3 fts5 来实现。这段时间再次入门 c++，所以想用 c++ 实现一下，一来用于练手，二来当时做的时候发现网络上这方面开源的实现不多，也造福下其他人。</p><h2 id=背景>背景<a href=#背景 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>搜索现在几乎是每个 APP 必备的功能，用户已经习惯了搜索框搜一下，避免到处去找。搜索也是帮助用户查找旧信息，发现新功能的一个重要手段。平常我们用微信的时候经常会搜索联系人和聊天记录，发现微信这一块做的还是非常好的。关于微信的全文搜索，可以看看这两篇文章：<a href=https://juejin.im/entry/59e6cd266fb9a0451968ab02>微信全文搜索优化之路</a> 和 <a href=https://cloud.tencent.com/developer/article/1198371>微信移动端的全文检索多音字问题解决方案</a> 。</p><p>第一篇文章主要是问题和原理的概述，第二篇文章是核心分词器的实现。我写的这个项目主要是实现了 simple 分词器，并提供一些辅助函数帮助使用。</p><h2 id=simple-分词器>Simple 分词器<a href=#simple-分词器 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>搜索的核心是建倒排索引，建索引的核心是分词器。 跟名字一下，Simple 分词器的规则非常简单：</p><ol><li>空白符跳过</li><li>连续的数字作为整体是一个索引</li><li>连续的英文字母作为整体并转换成小写索引</li><li>中文字单独建索引，并且把中文字转成拼音后也建搜索，这样就能同时支持中文和拼音检索。另外把拼音首字母也建索引，这样搜索 zjl 就能命中 &ldquo;周杰伦&rdquo;。</li><li>其他字符统一单独建索引，这样搜索 😊 也能搜到</li></ol><p>上面的 5 条都比较好理解，关于中文为什么这么做（而不是连续的中文一起建索引），是由于客户端搜索的需求决定的。具体可以参考上面微信的两篇文章。</p><p>有了上面的规则，代码写起来就很简单了，<a href=https://github.com/wangfenjin/simple/blob/a9234eb7169d98522ff07f42e0e9f9aa603bbebd/src/simple_tokenizer.cc#L104>核心逻辑</a> 30 行就解决了。这块代码运行效率也比较高，一遍扫描 O(n) 的复杂度就完成了分词操作。</p><h2 id=query-拆分>query 拆分<a href=#query-拆分 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>索引建好之后，query 需要根据分词规则来写才能查询到数据。比如根据上面的逻辑：</p><ol><li>如果查数字，我们要把搜索词当作前缀来用，比如用户搜索 123， query 就需要换成 123*，这样如果索引里面有 12345 也能被搜索出来</li><li>对于英文，除了要当作前缀，还需要把搜索词转成小写，比如用护搜索 Hello，query 就需要换成 hello*, 这样如果索引里面有 HelloWorld 也能被命中</li><li>对于中文和其他字符，都要拆成单个的才能命中索引</li><li>最后对于拼音（其实我们没办法区分英文和拼音，统一当作拼音处理就行），需要把拼音按照规则拆分，因为我们的拼音索引是单字建立的。这样如果用户搜索 &ldquo;zhangliangy&rdquo;，拼音就可以被拆成 &lsquo;zhang AND liang AND y*'，从而命中"张靓颖&rdquo;。具体规则微信的文章中也有详述。</li></ol><p>可以看到 query 词重构的逻辑也比较多，在之前的项目中没有好的办法，所以是自己在应用层代码里面组装好了 query 再给 sqlite 去搜的，这样其实不太方便。在这个项目中，我实现了一个 simple_query 的字符串函数，输入一个 string，它会给转换成组装好的搜索词，用法跟使用 sqlite 内置函数一样，这样就方便很多了，下面是一个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#75715e>-- 完整例子：https://github.com/wangfenjin/simple/blob/master/test.sql
</span><span style=color:#75715e></span>
<span style=color:#75715e>-- load so file
</span><span style=color:#75715e></span>.<span style=color:#66d9ef>load</span> libsimple.so

<span style=color:#75715e>-- set tokenize to simple
</span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> VIRTUAL <span style=color:#66d9ef>TABLE</span> t1 <span style=color:#66d9ef>USING</span> fts5(x, tokenize <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>simple</span><span style=color:#e6db74>&#34;</span>);

<span style=color:#75715e>-- add some values into the table
</span><span style=color:#75715e></span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t1 <span style=color:#66d9ef>values</span> (<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>周杰伦 Jay Chou:最美的不是下雨天，是曾与你躲过雨的屋檐</span><span style=color:#e6db74>&#34;</span>),

<span style=color:#75715e>-- query result: [周杰伦] Jay Chou:最美的不是下雨天，是曾与你躲过雨的屋檐
</span><span style=color:#75715e></span><span style=color:#66d9ef>select</span> simple_highlight(t1, <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>[</span><span style=color:#e6db74>&#39;</span>, <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>]</span><span style=color:#e6db74>&#39;</span>) <span style=color:#66d9ef>from</span> t1 <span style=color:#66d9ef>where</span> x <span style=color:#66d9ef>match</span> simple_query(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>zhoujiel</span><span style=color:#e6db74>&#39;</span>);
</code></pre></div><p>可以看到， match 后面用 simple_query 这个函数，传入用户输入的搜索词就可以用了。</p><p>另外 sql 中还有一个 simple_highlight 函数，它的作用和内置的 highlight 函数一样，只是它会把连续命中的词一起高亮。比如对于文档"周杰伦&rdquo;，如果搜索词是 &lsquo;zhou AND jie&rsquo;，那么 highlight 函数会返回 &ldquo;[周][杰]伦&rdquo;，simple_highlight 会返回 &ldquo;[周杰]伦&rdquo;。</p><h2 id=总结>总结<a href=#总结 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>最后说几句关于 sqlite fts5 的使用的问题。个人建议通过 trigger 的方式来维护索引的这张表，具体使用的方式可以在官方文章中搜索 trigger 找到例子。这样使用的好处是没有复杂的逻辑去保证文档数据和索引数据一致，微信的文章中很大一部分复杂度在描述怎么保证数据一致的问题。他们可能有自己的业务复杂性，但是对于一般的场景来说， trigger 是最好的方式。</p><p>从这个项目我们能学到：</p><ol><li>怎么给 sqlite3 做一个支持中文和拼音的 fts5 拓展</li><li>怎么给 sqlite3 添加用户自定义的函数</li><li>在一个项目中同时使用 c 和 c++ ，并合理处理边界问题</li></ol><p>大家可以下载使用，也可以根据自己的需求去改进，定制更多的函数和策略。</p><h2 id=reference>Reference<a href=#reference class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>Simple 分词器: <a href=https://github.com/wangfenjin/simple>https://github.com/wangfenjin/simple</a></li><li>sqlite 官方文档：<a href=https://www.sqlite.org/fts5.html>https://www.sqlite.org/fts5.html</a></li><li>微信全文搜索优化之路：<a href=https://juejin.im/entry/59e6cd266fb9a0451968ab02>https://juejin.im/entry/59e6cd266fb9a0451968ab02</a></li><li>微信移动端的全文检索多音字问题解决方案：<a href=https://cloud.tencent.com/developer/article/1198371>https://cloud.tencent.com/developer/article/1198371</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://www.wangfenjin.com/posts/spacemacs-intro/><span class=button__icon>←</span>
<span class=button__text>Spacemacs Intro</span></a></span>
<span class="button next"><a href=https://www.wangfenjin.com/posts/my-first-post/><span class=button__text>Showcase</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Copyright © 2021 Wang Fenjin :: Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://www.wangfenjin.com/assets/main.js></script><script src=https://www.wangfenjin.com/assets/prism.js></script></div></body></html>